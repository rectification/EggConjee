<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>Dreaming Cat's</title><meta name="description" content="闲言碎语"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/img/favicon.ico"><link rel="stylesheet" type="text/css" href="/css/style.css"><link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.dreamingcat.me/atom.xml" title="Dreaming Cat's"></head><body><header><div><div id="logo-img"><a href="/"><img src="/img/logo.png" alt="Dreaming Cat's" title="Dreaming Cat's"></a></div><div id="logo-text"><h1><a href="/" title="Dreaming Cat's">Dreaming Cat's</a></h1><h2>梦之上</h2></div><ul id="logo-list"><li><a href="/">主页</a></li><li><a href="/archives/">归档</a></li><li><a href="/categories/">分类</a></li><li><a href="/tags/">标签</a></li><li><a href="/archives/about/">关于</a></li><li><form class="search" action="//google.com/search" method="get" accept-charset="utf-8"><input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索"></form></li></ul></div></header><article id="container"><ul class="post-list" id="main"><li><header><a href="/archives/2016/10/simple-promise/" target="_blank">“简单”的Promise</a><time>2016-10-20</time></header><article><span>Promise是在ES6引入的，它的出现是为了解决JavaScript在异步编程上的缺陷。不仅解决了回调金字塔，还能够让我们更好的控制异步程序的流程。但我在使用它的过程中，却总觉得实在是有点难以理解，虽然它可以取消回调，但是它本身却又是依赖回调实现的，使用过程中各个函数跳来跳去的，实在是让我感到头晕。即便是在阅读了规范之后也觉得有点云里雾里，于是乎就决定自己尝试实现一个简单的Promise，以增进对它的理解。本文就是个人对于Promise的笔记。</span></article><footer class="post-footer"><span><a href="/categories/#软件设计">软件设计</a></span><span><a href="/tags/#JavaScript">JavaScript</a><a href="/tags/#规范">规范</a><a href="/tags/#异步">异步</a></span></footer></li><li><header><a href="/archives/2016/10/++[]-++[[]][0]/" target="_blank">++[] 与 ++[[]][0]</a><time>2016-10-10</time></header><article><span>这是个很有趣的问题，涉及到了JavaScript中很多基本的机制。这两个表达式看起来是一样的，但它们的运行结果却是大相径庭。网上关于它们之间的区别已经有了很多文章，但是我看了很多，却没有一篇能真正说服我，本文是我自己对于这个问题的看法和笔记。</span></article><footer class="post-footer"><span><a href="/categories/#软件设计">软件设计</a></span><span><a href="/tags/#JavaScript">JavaScript</a><a href="/tags/#规范">规范</a></span></footer></li><li><header><a href="/archives/2016/09/scope-closures/" target="_blank">作用域和闭包</a><time>2016-09-30</time></header><article><span>《你不懂JS》系列第二本，由书名就能看出来这一本的主要内容是什么。这本书先简单介绍了编译原理，然后再开始讲解作用域，作用域的诸多细节都有涉及到，最后花了很长篇幅来介绍闭包。不过有些地方我结合我自己的学习过程，觉得他讲的还是不太好，我不自量力的稍微做了点补充。本书原文的语言风格比较轻佻，很多夸张的描述和感叹，本人的英语水平实在是不太好，无法准确的还原，有些比喻可能看起来会比较尴尬……还请见谅。另外，本书前言以及鸣谢和第一本一模一样，本书以及系列之后的书都不再重复，如果想看的话，请看第一本。</span></article><footer class="post-footer"><span><a href="/categories/#你不懂JS">你不懂JS</a></span><span><a href="/tags/#JavaScript">JavaScript</a><a href="/tags/#翻译">翻译</a></span></footer></li><li><header><a href="/archives/2016/08/up-going/" target="_blank">Up &amp; Going</a><time>2016-08-02</time></header><article><span>《你不懂JS》系列第一本。说是第一本，但是从写作顺序上来说却并不是第一本，这个系列首先完成的是第二本《作用域与闭包》，这本书更像是为了凑成完整的系列而写的。说它是“凑数”的，并不是说它写的不好，这本书的质量也是很高的。不过，本书也只是编程（JavaScript）的入门书，如果你已经很了解JavaScript了，那么这本书你可以直接翻到第三章，看看系列后面的概要。</span></article><footer class="post-footer"><span><a href="/categories/#你不懂JS">你不懂JS</a></span><span><a href="/tags/#JavaScript">JavaScript</a><a href="/tags/#翻译">翻译</a></span></footer></li><li><header><a href="/archives/2016/06/closures-bind/" target="_blank">Function.prototype.bind</a><time>2016-06-08</time></header><article><span>这个东西是我偶然想到的，之前在写矩阵求解器的时候，给每个元素封装了很多接口，其中一个是某种特殊的运算，这个运算根据元素不同内部的参数也不同，最开始直接用的bind将参数绑定的，那速度简直太惨了，后来经人提醒换成了闭包，效果才比较能接受。于是我就有了探究bind方法的想法。</span></article><footer class="post-footer"><span><a href="/categories/#软件设计">软件设计</a></span><span><a href="/tags/#JavaScript">JavaScript</a><a href="/tags/#规范">规范</a></span></footer></li><li><header><a href="/archives/2016/03/requireJS-source/" target="_blank">requireJS源码浅析</a><time>2016-03-17</time></header><article><span>初次使用requireJs的时候有很多不甚明了的地方，于是乎就有了看看源码的心思，再加上它的代码加上注释也不过2000+行，而且注释又非常详尽，看起来貌似不怎么困难……我看之前是这么想的……结果发现其实很难……但是半途而废感觉又不太好，还是硬着头皮看了几遍，很多细节问题吃不透，只能理解个大概，本文是我自己的笔记，如果有错误还请指正。另外，本文看着很长，其实有大半都是源码的复制黏贴，水得很……</span></article><footer class="post-footer"><span><a href="/categories/#软件设计">软件设计</a></span><span><a href="/tags/#JavaScript">JavaScript</a><a href="/tags/#requireJS">requireJS</a><a href="/tags/#异步">异步</a></span></footer></li><li><header><a href="/archives/2016/02/function-dec-exp-ano/" target="_blank">函数声明与函数表达式</a><time>2016-02-18</time></header><article><span>函数声明和函数表达式是JavaScript初学者比较容易混淆的概念，它们似乎很相似，又似乎在哪里有点不一样，本文就主要讲述这俩的联系与区别，以及它们运用过程中的一些细节。</span></article><footer class="post-footer"><span><a href="/categories/#软件设计">软件设计</a></span><span><a href="/tags/#JavaScript">JavaScript</a><a href="/tags/#规范">规范</a></span></footer></li><li><header><a href="/archives/2015/01/algorithm-SOGI/" target="_blank">SOGI算法简析</a><time>2015-01-05</time></header><article><span>锁相环（PLL）技术，顾名思义就是相位同步的技术。在电力电子领域主要使用在逆变器、APF以及SVG等设备中。有很多种算法都能实现这个技术，本文主要介绍了个人认为其中比较有亮点的SOGI算法。</span></article><footer class="post-footer"><span><a href="/categories/#软件设计">软件设计</a></span><span><a href="/tags/#C">C</a><a href="/tags/#PLL">PLL</a><a href="/tags/#算法">算法</a><a href="/tags/#滤波器">滤波器</a></span></footer></li><li><header><a href="/archives/2014/12/Tuf-Voyaging/" target="_blank">《图夫航行记》</a><time>2014-12-18</time></header><article><span>这本书给我的印象和往常的乔治马丁大爷相去甚远，这本小说很可能是马丁老爷缺零花钱了才写出来的（雾）……</span><span>本书的题材即便是在光怪陆离的SF题材中也算是很特别的，书中描绘的最主要的技术是——生态学。这门学科和生物学有些不同，生物学研究的是生物本身，而生态学研究的是生物与生物、生物与环境之间的关系。</span></article><footer class="post-footer"><span><a href="/categories/#杂物堆积处">杂物堆积处</a></span><span><a href="/tags/#闲话">闲话</a></span></footer></li><li><header><a href="/archives/2014/11/amplifier-limit/" target="_blank">运放限幅电路</a><time>2014-11-13</time></header><article><span>在各种控制系统中，PID控制器之后必然有一个限幅过程，对于数字控制器而言，不过只是两个if语句的事情；但对于模拟控制器而言，却要麻烦的多。简单点的会使用运放上下限来作为输出电压的限制，但是有少部分情况需要极其特殊的限制电压，本文主要内容就是如何使用运放和钳位二极管来实现任意电压的限幅。</span></article><footer class="post-footer"><span><a href="/categories/#硬件设计">硬件设计</a></span><span><a href="/tags/#运放">运放</a></span></footer></li><li><header><a href="/archives/2014/09/algorithm-CRODIC/" target="_blank">CRODIC算法简析</a><time>2014-09-25</time></header><article><span>初等函数是数值计算里老生常谈的话题了，现在最常用的办法无非就是泰勒展开、切比雪夫逼近等等方法。计算精度是有的，但是全浮点的运算，在一些低廉的硬件系统之中仍然受到了很大的限制，邪道点的方法比如直接打表hash查找，虽然时间上达到了O(1)的效果，但是不可避免的会消耗大量的硬件空间，内部空间够用那还好说，如果不够用的话，势必就需要外接储存器，但是MCU和外接储存器通信又要耗费时间，这又有点本末倒置了。那么，有没有折衷的方法呢？答案当然是有的，这就是本文要介绍的CRODIC算法，即坐标旋转数字计算(Coordinate Rotation Digital Computer)。</span></article><footer class="post-footer"><span><a href="/categories/#软件设计">软件设计</a></span><span><a href="/tags/#C">C</a><a href="/tags/#数值求解">数值求解</a><a href="/tags/#算法">算法</a></span></footer></li><li><header><a href="/archives/2014/08/bridge-rectifier/" target="_blank">单相桥式整流</a><time>2014-08-12</time></header><article><span>单相不可控整流电路，这应该是电系大学生们在大学中学习的最早也是最常用的电路之一。但是与之相反的是，关于这个电路的计算资料很少，而且大都也就给出一个经验公式，没有从原理上来分析这个电路，教科书上的计算又过于繁琐，不利于运用到实际之中。本文旨在从瞬态分析和能量交换的角度对这个电路进行简单分解，提出了个比较通用的计算方法。</span></article><footer class="post-footer"><span><a href="/categories/#硬件设计">硬件设计</a></span><span><a href="/tags/#滤波器">滤波器</a></span></footer></li><li><header><a href="/archives/2014/06/hello-world/" target="_blank">Hello World</a><time>2014-06-01</time></header><article><span>惯例的第一篇文章。</span></article><footer class="post-footer"><span><a href="/categories/#杂物堆积处">杂物堆积处</a></span><span><a href="/tags/#闲话">闲话</a></span></footer></li></ul><aside><div><div class="categories-list"><p>分类</p><ul><li><a href="/categories/#软件设计" title="软件设计">软件设计<sup>7</sup></a></li><li><a href="/categories/#你不懂JS" title="你不懂JS">你不懂JS<sup>2</sup></a></li><li><a href="/categories/#杂物堆积处" title="杂物堆积处">杂物堆积处<sup>2</sup></a></li><li><a href="/categories/#硬件设计" title="硬件设计">硬件设计<sup>2</sup></a></li></ul></div><div class="tags-list"><p>标签</p><ul><li><a href="/tags/#JavaScript" title="JavaScript">JavaScript<sup>7</sup></a></li><li><a href="/tags/#规范" title="规范">规范<sup>4</sup></a></li><li><a href="/tags/#异步" title="异步">异步<sup>2</sup></a></li><li><a href="/tags/#翻译" title="翻译">翻译<sup>2</sup></a></li><li><a href="/tags/#requireJS" title="requireJS">requireJS<sup>1</sup></a></li><li><a href="/tags/#C" title="C">C<sup>2</sup></a></li><li><a href="/tags/#PLL" title="PLL">PLL<sup>1</sup></a></li><li><a href="/tags/#算法" title="算法">算法<sup>2</sup></a></li><li><a href="/tags/#滤波器" title="滤波器">滤波器<sup>2</sup></a></li><li><a href="/tags/#闲话" title="闲话">闲话<sup>2</sup></a></li><li><a href="/tags/#运放" title="运放">运放<sup>1</sup></a></li><li><a href="/tags/#数值求解" title="数值求解">数值求解<sup>1</sup></a></li></ul></div><div class="links-list"><p>链接</p><ul><li><a href="https://xiaoboost.github.io/circuitlab/" title="电路仿真" target="_blank">电路仿真</a></li></ul></div></div></aside></article><footer>Powered by&nbsp;<a href="/">Xiao</a> © 2014 - 2016<div id="goto-up"></div></footer><script type="text/javascript" src="/js/jquery-3.1.0.min.js"></script><script type="text/javascript" src="/js/page.js"></script></body></html>