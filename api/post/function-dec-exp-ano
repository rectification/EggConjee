{"path":"/post/function-dec-exp-ano","name":"function-dec-exp-ano","title":"函数声明与函数表达式","category":"软件设计","date":["2016","02","18"],"tag":["JavaScript","规范"],"layout":"post","toc":[{"tocTitle":"语法","bolt":"BE8AFADE6B395"},{"tocTitle":"声明提升","bolt":"BE5A3B0E6988EE68F90E58D87","child":[{"tocTitle":"函数表达式赋值的死区","bolt":"BE587BDE695B0E8A1A8E8BEBEE5BC8FE8B58BE580BCE79A84E6ADBBE58CBA","parent":"BE5A3B0E6988EE68F90E58D87"}]},{"tocTitle":"函数表达式的匿名与具名","bolt":"BE587BDE695B0E8A1A8E8BEBEE5BC8FE79A84E58CBFE5908DE4B88EE585B7E5908D"},{"tocTitle":"立即执行函数","bolt":"BE7AB8BE58DB3E689A7E8A18CE587BDE695B0"},{"tocTitle":"总结","bolt":"BE680BBE7BB93"}],"excerpt":["函数声明和函数表达式是JavaScript初学者比较容易混淆的概念，它们似乎很相似，又似乎在哪里有点不一样，本文就主要讲述这俩的联系与区别，以及它们运用过程中的一些细节。"],"next":{"path":"/post/requirejs-source","title":"requireJS源码浅析"},"prev":{"path":"/post/algorithm-sogi","title":"SOGI算法简析"},"content":"<p class=\"warning\"><span>本文中的所有规范均是ES6版本的。</span></p><p><span>这俩哥们是JavaScript初学者非常容易弄混淆的概念，主要是这俩太过似是而非了。它们虽然都可以用来定义函数，但是它们之间也都有些微妙的区别。</span></p><p><span>它们在代码中通常都是这样的：</span></p><pre class=\"javascript\"><code><ul class=\"gutter\"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li></ul><ul class=\"code\"><li><span class=\"hljs-comment\">//函数声明</span></li><li><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn1</span>(<span class=\"hljs-params\">a</span>) </span>{   </li><li>  <span class=\"hljs-built_in\">console</span>.log(a);</li><li>}</li><li></li><li><span class=\"hljs-comment\">//函数表达式</span></li><li><span class=\"hljs-keyword\">var</span> fn2 = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">a</span>) </span>{       </li><li>  <span class=\"hljs-built_in\">console</span>.log(a);</li><li>}</li></ul></code></pre><ul><li><p><span>函数声明直接使用了<code>function</code>声明并指定函数名称。</span></p></li><li><p><span>函数表达式是先定义了一个函数然后将这个函数赋值给了一个变量。</span></p></li></ul><p><span>这就是一般意义上的函数声明和函数表达式了，但是实际上这并不准确。那么这两者的准确定义是什么？这就要先从它们的语法形式开始说起了。</span></p><h1 id=\"BE8AFADE6B395\">语法</h1><p><span>规范之中对它们的语法是这样定义的——</span></p><blockquote><p><span>13 Function Definition # Ⓣ Ⓡ</span><span>Syntax</span><span><em>FunctionDeclaration</em> :</span><span>　　function <em>Identifier</em> ( <em>FormalParameterList</em><sub>opt</sub> ) { <em>FunctionBody</em> }</span><span><em>FunctionExpression</em> :</span><span>　　function <em>Identifier</em><sub>opt</sub> ( <em>FormalParameterList</em><sub>opt</sub> ) { <em>FunctionBody</em> }</span></p></blockquote><p><span>可以很明显的看出，从语法上来说，函数声明与函数表达式只有一个标识符（<code>Identifier</code>）的差别，函数声明必须拥有标识符，而函数表达式的标识符是可选的（<code>opt</code>）,就是说函数表达式可以是匿名函数。</span></p><p><span>再来看看句法结构：</span></p><blockquote><p><span>Program :</span><span>　　SourceElements<sub>opt</sub></span><span>SourceElements :</span><span>​　　SourceElement</span><span>　　SourceElements SourceElement</span><span>SourceElement :</span><span>　　Statement</span><span>　　FunctionDeclaration</span><span>Statement : </span><span>　　……</span><span>　　ExpressionStatement :</span><span>　　　　[lookahead ∉ {{, function, class, let [} Expression ;</span><span>　　……</span></p></blockquote><p><span>我省略了部分结构，js的语法解析树从<code>Program</code>为根节点依次向下，可以看到<code>FunctionDeclaration</code>和<code>Statement</code>是同一个级别的，同样会归约到<code>SourceElement</code>节点。而只要语句不是以<code>{</code>、<code>function</code>、<code>class</code>、<code>let</code>、<code>[</code>开头的，那么当前语句就会被解析成为<code>ExpressionStatement</code>。</span><span>所以js解析器在进行词法分析的时候，当它碰到了<code>function(){}</code>这个语句，很明显这个语句是<code>function</code>开头的，那么它会优先解析成<code>FunctionDeclaration</code>，随后对它做格式检查，这个语句之中并没有指定函数的标识符名称，所以这里肯定就会抛出一个语法错误。</span></p><pre class=\"javascript\"><code><ul class=\"gutter\"><li>1</li></ul><ul class=\"code\"><li>Uncaught <span class=\"hljs-built_in\">SyntaxError</span>: Unexpected token (</li></ul></code></pre><p><span>语法错误，意外的标记<code>(</code>。</span><span>所以以<code>function</code>开头的语句，必然会被解析成为函数声明，而函数声明就必须要有标识符名字。</span></p><p><span>所以，只要语句的开头不是<code>function</code>，那么它就不会被解释器认为是函数声明了。具体来说，就是以别的符号（标记）来作为语句的开头，提示解释器这里并不是函数声明，不能按照函数声明来解析。</span><span>比如在语句开头使用一元运算符，又比如将它放在<code>if</code>的条件之中，只要按照规则将它放在应该是表达式的地方，解释器就会把它按照是表达式的方式进行解析。确定了是表达式，再碰到<code>function</code>开头的语句，那肯定就会解析成函数表达式了。</span><span>比如，下列这些语句就都是合法的。</span></p><pre class=\"javascript\"><code><ul class=\"gutter\"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li></ul><ul class=\"code\"><li>!<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{ <span class=\"hljs-comment\">/* code */</span> };</li><li>~<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{ <span class=\"hljs-comment\">/* code */</span> };</li><li>-<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{ <span class=\"hljs-comment\">/* code */</span> };</li><li>+<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{ <span class=\"hljs-comment\">/* code */</span> };</li><li></li><li><span class=\"hljs-keyword\">if</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{ <span class=\"hljs-comment\">/* code */</span> }) {};</li></ul></code></pre><p><span>当然，函数表达式最常见的用法还是<code>var test = function(){}</code>，函数表达式赋值。</span></p><h1 id=\"BE5A3B0E6988EE68F90E58D87\">声明提升</h1><p><span>JavaScript的声明具有提升效果，但是函数声明和变量声明的优先级是不一样的，那么函数表达式赋值语句和函数声明的优先级是怎么算的呢？</span><span>请看下面的两段代码——</span></p><pre class=\"javascript\"><code><ul class=\"gutter\"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li><li>11</li><li>12</li><li>13</li><li>14</li><li>15</li><li>16</li><li>17</li><li>18</li><li>19</li></ul><ul class=\"code\"><li>A:</li><li><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn1</span>(<span class=\"hljs-params\"></span>) </span>{</li><li>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"1\"</span>);</li><li>}</li><li><span class=\"hljs-keyword\">var</span> fn2 = fn1;</li><li><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn1</span>(<span class=\"hljs-params\"></span>) </span>{</li><li>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"2\"</span>);</li><li>}</li><li>fn2();         <span class=\"hljs-comment\">//2;</span></li><li></li><li>B:</li><li><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn1</span>(<span class=\"hljs-params\"></span>)</span>{</li><li>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"1\"</span>);</li><li>}</li><li><span class=\"hljs-keyword\">var</span> fn2 = fn1;</li><li>fn1 = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{</li><li>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"2\"</span>);</li><li>}</li><li>fn2();        <span class=\"hljs-comment\">//1;</span></li></ul></code></pre><p><span>这两段代码的区别就在于<code>fn1</code>第二次定义的时候上面采用的是函数声明，而下面是函数表达式。</span><span>这个现象的原因很容易就能想到。在上面已经提到过了，函数声明<code>FunctionDeclaration</code>的优先级比较高，这就导致函数声明将会被提升至当前作用域的最上端。而对于函数表达式，函数本身被当作了一个值，那么它所在的赋值语句实际上被认为是<code>变量声明</code>了。所以上面的两段代码其实应该等效为——</span></p><pre class=\"javascript\"><code><ul class=\"gutter\"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li><li>11</li><li>12</li><li>13</li><li>14</li><li>15</li><li>16</li><li>17</li><li>18</li><li>19</li><li>20</li><li>21</li></ul><ul class=\"code\"><li>A:</li><li><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn1</span>(<span class=\"hljs-params\"></span>) </span>{</li><li>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"1\"</span>);</li><li>}</li><li><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn1</span>(<span class=\"hljs-params\"></span>) </span>{</li><li>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"2\"</span>);</li><li>}</li><li><span class=\"hljs-keyword\">var</span> fn2;</li><li>fn2 = fn1;</li><li>fn2();</li><li></li><li>B:</li><li><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn1</span>(<span class=\"hljs-params\"></span>) </span>{</li><li>  alert(<span class=\"hljs-string\">\"1\"</span>);</li><li>}</li><li><span class=\"hljs-keyword\">var</span> fn2;</li><li>fn2 = fn1;</li><li>fn1 = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{</li><li>  alert(<span class=\"hljs-string\">\"2\"</span>);</li><li>}</li><li>fn2();</li></ul></code></pre><p><span>所以，函数声明的优先级最高，而函数表达式会被当作一个值来操作，它的声明是否提升取决于它被赋值的变量。</span></p><h2 id=\"BE587BDE695B0E8A1A8E8BEBEE5BC8FE8B58BE580BCE79A84E6ADBBE58CBA\">函数表达式赋值的死区</h2><p><span>对于函数声明，由于提升的关系，它的作用域属于整个封闭作用域内部，所以这个函数可以在作用域内部任何地方使用。比如：</span></p><pre class=\"javascript\"><code><ul class=\"gutter\"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li></ul><ul class=\"code\"><li>test();    <span class=\"hljs-comment\">//test</span></li><li></li><li><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">test</span>(<span class=\"hljs-params\"></span>) </span>{</li><li>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"test\"</span>);</li><li>}</li><li></li><li>test();    <span class=\"hljs-comment\">//test</span></li></ul></code></pre><p><span>对于函数表达式赋值语句而言，它是否提升是依赖于被赋值的变量的，并且即便是提升，也是那个被赋值的标识符提升，函数本身是没有跟着提升的。这样就会造成一个死区，即标识符存在，但是函数却不存在的区域。看代码：</span></p><pre class=\"javascript\"><code><ul class=\"gutter\"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li></ul><ul class=\"code\"><li><span class=\"hljs-keyword\">typeof</span> test;    <span class=\"hljs-comment\">//\"undefined\"</span></li><li>test();            <span class=\"hljs-comment\">//Uncaught TypeError</span></li><li></li><li><span class=\"hljs-keyword\">var</span> test = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{</li><li>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"test\"</span>);</li><li>}</li></ul></code></pre><p><span>发生了类型错误。<code>TypeError</code>就意味着，当前这个标识符在作用域中被找到了，但是当前运算所需要的类型和它本身的类型不匹配。从第一句<code>typeof</code>可以看出，标识符已经存在，但是值是<code>undefined</code>。</span><span>所以说，从当前作用域开始，直到赋值语句所在的语句，这之间的区域内，变量存在，但是函数却不存在。这也就是所谓“死区”。</span><span>这也是很多人喜欢使用函数表达式赋值语句代替声明的原因，这将会强制在定义了函数之后再使用它们，因为在定义之前提前使用函数，这有可能会造成代码逻辑上的混乱。</span></p><h1 id=\"BE587BDE695B0E8A1A8E8BEBEE5BC8FE79A84E58CBFE5908DE4B88EE585B7E5908D\">函数表达式的匿名与具名</h1><p><span>很多人可能都没有注意到这一点，毕竟大多数使用函数表达式赋值的人，通常使用的都是匿名函数。</span><span>但是，假如你在使用函数表达式赋值的时候，这个函数是具名的，那么这个函数标识符的作用域是属于哪里的？</span><span>来看下面的代码：</span></p><pre class=\"javascript\"><code><ul class=\"gutter\"><li>1</li><li>2</li><li>3</li><li>4</li></ul><ul class=\"code\"><li><span class=\"hljs-keyword\">var</span> test = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">ss</span>(<span class=\"hljs-params\"></span>)</span>{</li><li>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"test\"</span>);</li><li>}</li><li>ss();</li></ul></code></pre><p><span>来猜猜它的结果如何？</span></p><p><span>我就不卖关子了，这里会抛出<code>ReferenceError</code>，也就是引用错误。所谓引用错误，就是说这个你引用的标识符在当前作用域内就不存在。</span><span>为什么会这样？给函数表达式中的函数加上标识符，这种形式叫做<code>具名函数表达式</code>，它的运行方式和匿名函数表达式以及普通函数表达式有很大的不同。</span></p><p><span>不管是函数声明，还是匿名具名的函数表达式，它们的声明实例化都是通过调用<code>FunctionDeclarationInstantiation</code>这个抽象方法来实现的，这个方法很长，我就不贴了，有兴趣的可以看看这个链接（<a href=\"https://tc39.github.io/ecma262/#sec-functiondeclarationinstantiation\">函数声明实例化</a>）。</span><span><code>函数声明</code>在其中会调用<code>CreateMutableBinding</code>方法，这个方法会在当前环境中创建一个新的，但是还未初始化的可绑定的环境记录。这也就意味着，这个函数标识符就会存在于作用域内部了。</span><span><code>匿名函数表达式</code>在其中同样调用<code>CreateMutableBinding</code>方法，但是标识符却是函数体的内部<code>text</code>代码。其余和函数声明一样。</span><span>而对于<code>具名函数表达式</code>，它则会调用<code>NewDeclarativeEnvironment</code>。该方法将创建一个新的空词法环境，这个新的词法环境将会嵌套在当前的环境中，然后以新的词法环境为作用域，将这个函数的标识符绑定在这个新的词法作用域内部，最后将函数的引用交给左侧的变量。因此这里的函数标识符是绑定在新的词法环境中的，外部环境也就无法找到它。</span></p><p><span>至于这么设计的原因，我觉得可能是为了解决两个问题：</span></p><ol><li><p><span>防止函数表达式的标识符污染外部作用域。</span></p></li><li><p><span>让函数表达式内部可以使用递归等需要引用自身代码。</span></p></li></ol><h1 id=\"BE7AB8BE58DB3E689A7E8A18CE587BDE695B0\">立即执行函数</h1><p><span>常见的立即执行函数有两种写法<code>( function(){…} )()</code>和<code>( function (){…} () )</code>，很多人对这两种形式到底有什么区别比较感兴趣，我在这里简单说说。</span><span>通过第一章的分析，很明显这里的小括号只是起着提示这里是表达式的作用。</span></p><p><span>括号，在JavaScript中被称作括号运算符（<code>Grouping Operator</code>），它一共有3个静态语义：<code>Early Errors</code>、<code>IsFunctionDefinition</code>以及<code>IsValidSimpleAssignmentTarget</code>；另外还有1个动态语义：<code>Evaluation</code>。</span><span>静态语义是在代码运行之前的时候辅助预编译的，这里可以先不管它，我们只需要关注动态语义。</span><span><code>Evaluation</code>这个语义，直译是<code>评估</code>，怎么说呢……我实在不好描述它到底是干嘛的……它在规范中无处不在，无论是调用函数还是表达式求值，首先运行的就是它，它取出式子，经过了某种转换，然后再运行/求值，我觉得可以当作是某种转换操作吧，但是它对于语义本身是没有任何影响的。</span></p><p><span>为了验证这点，我们可以找个AST语法树构建工具来为这两者构建语法树，看看结果怎样。这里我选用了<code>uglify-js</code>，由它内置的分析器来构建语法树。结果如下：</span></p><pre class=\"javascript\"><code><ul class=\"gutter\"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li><li>11</li><li>12</li><li>13</li><li>14</li><li>15</li><li>16</li><li>17</li><li>18</li><li>19</li><li>20</li><li>21</li><li>22</li><li>23</li><li>24</li><li>25</li><li>26</li><li>27</li></ul><ul class=\"code\"><li><span class=\"hljs-comment\">//语句</span></li><li>( <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{} )();</li><li><span class=\"hljs-comment\">//语法树</span></li><li>ast = {</li><li>  <span class=\"hljs-attr\">type</span>:<span class=\"hljs-string\">\"Program\"</span>,</li><li>  <span class=\"hljs-attr\">body</span>:[</li><li>    type: <span class=\"hljs-string\">\"ExpressionStatement\"</span>,</li><li>    <span class=\"hljs-attr\">expression</span>: {</li><li>      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"CallExpression\"</span>,</li><li>      <span class=\"hljs-attr\">arguments</span>: []</li><li>    }</li><li>  ]</li><li>}</li><li></li><li><span class=\"hljs-comment\">//语句</span></li><li>( <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{}() );</li><li><span class=\"hljs-comment\">//语法树</span></li><li>ast = {</li><li>  <span class=\"hljs-attr\">type</span>:<span class=\"hljs-string\">\"Program\"</span>,</li><li>  <span class=\"hljs-attr\">body</span>:[</li><li>    type: <span class=\"hljs-string\">\"ExpressionStatement\"</span>,</li><li>    <span class=\"hljs-attr\">expression</span>: {</li><li>      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"CallExpression\"</span>,</li><li>      <span class=\"hljs-attr\">arguments</span>: []</li><li>    }</li><li>  ]</li><li>}</li></ul></code></pre><p><span>可以看到，两者最后生成的语法树一模一样，最后都是函数调用。因此，就解释器而言，这俩是完全一样的，没有任何区别。</span></p><h1 id=\"BE680BBE7BB93\">总结</h1><ol><li><p><span>从语法上来说，语句<code>function</code>开头的时候，解释器就会把这句话当作是函数声明；想要解释器按照函数表达式进行解析，就需要和运算符以及和需要表达式的其他关键字配合。</span></p></li><li><p><span>函数和变量有声明提升，函数声明会属于全部封闭作用域，但是函数表达式会有死区区间存在，即变量标识符存在，但函数却不存在的区域。</span></p></li><li><p><span>具名函数表达式的函数标识符的作用域是属于它自己的，在外部作用域中不存在。</span></p></li><li><p><span>立即执行函数的两种写法从语法上来说有微妙的区别，但是最后生成的语法树一模一样，没有区别。</span></p></li></ol>"}