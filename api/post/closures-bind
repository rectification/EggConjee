{"path":"/post/closures-bind","name":"closures-bind","title":"Function.prototype.bind","category":"软件设计","date":["2016","06","08"],"tag":["JavaScript","规范"],"layout":"post","toc":"true","excerpt":["这个东西是我偶然想到的，之前在写矩阵求解器的时候，给每个元素封装了很多接口，其中一个是某种特殊的运算，这个运算根据元素不同内部的参数也不同，最开始直接用的bind将参数绑定的，那速度简直太惨了，后来经人提醒换成了闭包，效果才比较能接受。于是我就有了探究bind方法的想法。"],"markdown":"<p class=\"warning\">\n本文中的所有规范均是ES6版本的。\n</p>\n\nJavaScript中的函数也是值，当然也可以到处传递，经常会有这样的需求，那就是根据不同情况生成不同的函数，函数的主体结构是一样的，只是内部有些参数不同。实现这样的需求并不难，有两种比较典型的做法，一个是使用闭包，在闭包中保存参数最后返回函数本身，还有一个就是用函数直接将参数bind，这样在函数内就能直接使用`this`了。\n闭包自不必说了，除了作用域不会被垃圾回收之外，它的调用和普通函数一样，本文主要就是讲述`bind`之后的函数相比普通函数的区别。\n\n# 实验\n先做个简单的实验：\n```javascript\nfunction func (method) {\n    var obj = { \"name\" : 1 };\n\t\n    if(method === 1) {\n\t\treturn(function(i) {\n\t\t\tobj.name = i;\n\t\t});\n    } else if(method === 2) {\n\t\treturn(function(i) {\n\t\t\tthis.name = i;\n\t\t}.bind(obj));\n\t}\n}\nfunction test (func) {\n\tlet i;\n\tfor (i = 0;i < 10000000; i++)  {\n\t\tfunc(i);\n\t}\n}\nconsole.time('Closure');\ntest(func(1));\nconsole.timeEnd('Closure');\nconsole.time('Bind');\ntest(func(2));\nconsole.timeEnd('Bind');\n\n//Closure: 6.058ms\n//Bind: 86.811ms\n```\n\n`func`函数中有一个公共的对象obj，当`method === 1`的时候返回一个直接操作obj的函数，这是闭包方法；当`method === 2`的时候返回一个操作this指针的函数，而这个函数将绑定`obj`为它的`this`。\n结果差异非常显著：由于电脑性能的不同，在不同电脑上运行的结果可能会有差异，但是这个近14倍的差距确是毋容置疑的。\n\n到底是什么造成了这样的差距？\n\n# 函数调用\n先来说说函数调用，函数调用实际上就是调用函数对象内置的`[[call]]`方法，普通函数对象的这个方法在规范中是这样的：\n> [[Call]] ( thisArgument, argumentsList)\n1. Assert: F is an ECMAScript function object.\n2. If F’s [[FunctionKind]] internal slot is \"classConstructor\", throw a TypeError exception.\n3. Let callerContext be the running execution context.\n4. Let calleeContext be PrepareForOrdinaryCall(F, undefined).\n5. Assert: calleeContext is now the running execution context.\n6. Perform OrdinaryCallBindThis(F, calleeContext, thisArgument).\n7. Let result be OrdinaryCallEvaluateBody(F, argumentsList).\n8. Remove calleeContext from the execution context stack and restore callerContext as the running execution context.\n9. If result.[[type]] is return, return NormalCompletion(result.[[value]]).\n10. ReturnIfAbrupt(result).\n> 11. Return NormalCompletion(undefined).\n\n虽然很长，其实很简单的：\n1. 令`F`为函数对象\n2. 令`callerContext`为函数运行的上下文\n3. 绑定当前函数的`this`\n4. 运行当前函数，并令`result`为函数运行结果\n5. 若`result`有值，那么返回它，否则返回`undefined`\n\n我们都知道，`bind`方法将会改变函数运行的上下文，也就是改变函数运行时的`this`，上文中我们也看到普通函数调用也是要绑定`this`的，那么我们先看看它是如何在运行时绑定`this`的。\n\n在上述步骤中，绑定`this`的是这个函数`OrdinaryCallBindThis`，我们继续看规范：\n> OrdinaryCallBindThis ( F, calleeContext, thisArgument )\n1. Let thisMode be the value of F’s [[thisMode]] internal slot.\n2. If thisMode is lexical, return NormalCompletion(undefined).\n3. Let calleeRealm be the value of F’s [[Realm]] internal slot.\n4. Let localEnv be the LexicalEnvironment of calleeContext.\n5. If thisMode is strict, let thisValue be thisArgument.\n6. Else\n   1. if thisArgument is null or undefined, then\n      1. Let thisValue be calleeRealm.[[globalThis]].\n   2. Else\n      1. Let thisValue be ToObject(thisArgument).\n      2. Assert: thisValue is not an abrupt completion.\n      3. NOTE ToObject produces wrapper objects using calleeRealm.\n7. Let envRec be localEnv’s EnvironmentRecord.\n8. Assert: The next step never returns an abrupt completion because envRec.[[thisBindingStatus]] is not \"uninitialized\".\n> 9. Return envRec.BindThisValue(thisValue).\n\n这里就比较复杂了，变量也比较多，咱们挨个来。\n`thisMode`，这个变量是来自函数`F`的内部参数`[[ThisMode]]`，这个值代表着函数内`this`的取值方式，它一共有三个取值：\n1. `lexical`，此时`this`的值将会是函数所在封闭作用域的那个`this`（箭头函数的`词法this`）\n2. `strict`，此时`this`会等于函数调用的变量`thisArgument`\n3. `global`，如果此时`thisArgument`未定义，那么此时`this`会指向全局变量\n\n`calleeRealm`，这个变量是函数`F`的内部参数`[[Realm]]`，它是在函数运行之前的准备数据。但是，它并不是环境参数，代表函数词法环境的是另一个内建参数`[[Environment]]`。\n`calleeContext`，这个输入的变量代表着执行的上下文环境。\n`localEnv`，这个变量是`calleeContext`之中的词法环境。\n`envRec`，而这个变量是`localEnv`之中的环境记录，它包含了当前运行环境中的所有声明和对象环境。\n在最后，将`thisValue`绑定到`envRec`之中，函数运行的准备就完成了。\n\n可以看到，在普通的函数调用中，`this`的绑定是由运行时的上下文来决定的。函数调用就是调用函数对象自身的`[[call]]`方法。\n\n# `bind`方法\n那么，我们现在再来看看`bind`方法都做了什么：\n> Function.prototype.bind ( thisArg, ...args)\n1. Let Target be the this value.\n2. If IsCallable(Target) is false, throw a TypeError exception.\n3. Let args be a new (possibly empty) List consisting of all of the argument values provided after thisArg in order.\n4. Let F be ? BoundFunctionCreate(Target, thisArg, args).\n5. Let targetHasLength be ? HasOwnProperty(Target, \"length\").\n6. If targetHasLength is true, then\n   1. Let targetLen be ? Get(Target, \"length\").\n   2. If Type(targetLen) is not Number, let L be 0.\n   3. Else,\n      1. Let targetLen be ToInteger(targetLen).\n      2. Let L be the larger of 0 and the result of targetLen minus the number of elements of args.\n7. Else, let L be 0.\n8. Perform ! DefinePropertyOrThrow(F, \"length\", PropertyDescriptor {[[Value]]: L, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true}).\n9. Let targetName be ? Get(Target, \"name\").\n10. If Type(targetName) is not String, let targetName be the 11. empty string.\n12. Perform SetFunctionName(F, targetName, \"bound\").\n> 13. Return F.\n\n可以看到，在这里它创建并返回了个新的函数`F`，这个函数的诸多属性和原本的函数都是一样的，唯一有一点，就是构造这个新函数的方法是`BoundFunctionCreate`。\n我们来看看这个特殊的方法是什么：\n\n> BoundFunctionCreate (targetFunction, boundThis, boundArgs)\n1. Assert: Type(targetFunction) is Object.\n2. Let proto be ? targetFunction.[[GetPrototypeOf]]\\(\\).\n3. Let obj be a newly created object.\n4. Set obj's essential internal methods to the default ordinary object definitions specified in 9.1.\n5. Set the [[Call]] internal method of obj as described in 9.4.1.1.\n6. If targetFunction has a [[Construct]] internal method, then\n   1. Set the [[Construct]] internal method of obj as described in 9.4.1.2.\n7. Set obj.[[Prototype]] to proto.\n8. Set obj.[[Extensible]] to true.\n9. Set obj.[[BoundTargetFunction]] to targetFunction.\n10. Set obj.[[BoundThis]] to boundThis.\n11. Set obj.[[BoundArguments]] to boundArgs.\n> 12. Return obj.\n\n可以看到，这个构造函数的实例是继承了原版函数的，不过修改了`[[call]]`属性，而且还新增加了`[[BoundTargetFunction]]`、`[[BoundThis]]`以及`[[BoundArguments]]`这三个属性。\n这三个新增的属性，从名字就能看出它们是绑定的目标函数，绑定的`this`，以及绑定的输入参数。\n这个新的实例在规范中的名字是叫`bound function`。好直白……绑定函数……\n\n# 绑定函数的调用\n既然最终返回的`F`函数还修改了`[[call]]`，那么这个新的`[[call]]`是什么样的呢：\n> [[Call]] ( thisArgument, argumentsList)\n1. Let target be F.[[BoundTargetFunction]].\n2. Let boundThis be F.[[BoundThis]].\n3. Let boundArgs be F.[[BoundArguments]].\n4. Let args be a new list containing the same values as the list boundArgs in the same order followed by the same values as the list argumentsList in the same order.\n> 5. Return ? Call(target, boundThis, args).\n\n就是把内部参数取出之后调用了`Call`。这个`Call`是JavaScript内部的抽象函数，并没有对外暴露的，它的过程其实很简单。\n> Call (F, V [ , argumentsList ])\n1. If argumentsList was not passed, let argumentsList be a new empty List.\n2. If IsCallable(F) is false, throw a TypeError exception.\n> 3. Return ? F.[[Call]]\\(V, argumentsList\\).\n\n可以看到它只是做了格式检查，然后就直接调用函数`F`了。这个函数`F`就是原来我们绑定的原函数，这里就又回到普通函数调用那里了。\n\n# 总结\n到此为止我们可以看出，我们可以做总结了：\n1. 函数调用，实际上都是调用其内部的`[[call]]`方法。\n2. `bind`方法会生成一个继承自`Function`的实例，这个实例外带新增了三个参数（绑定时的参数），并修改了自身的`[[call]]`。\n3. `bind`方法生成的函数在调用的时候依旧会调用内部的`[[call]]`方法，但是这个方法只是取出参数之后又去调用了另外一个`Call`函数，最后才会调用真正的函数。\n4. 也就是说`bind`方法生成的函数最后在调用的时候，比普通的函数调用多了2个步骤。那么它比闭包的函数速度慢也确实是理所当然的。","next":{"path":"/post/up-going","title":"Up & Going"},"prev":{"path":"/post/requirejs-source","title":"requireJS源码浅析"}}