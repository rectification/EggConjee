{"path":"/post/algorithm-crodic","name":"algorithm-crodic","title":"CRODIC算法简析","category":"软件设计","date":["2014","09","25"],"tag":["C","数值求解","算法"],"layout":"post","toc":"true","excerpt":["初等函数是数值计算里老生常谈的话题了，现在最常用的办法无非就是泰勒展开、切比雪夫逼近等等方法。计算精度是有的，但是全浮点的运算，在一些低廉的硬件系统之中仍然受到了很大的限制，邪道点的方法比如直接打表hash查找，虽然时间上达到了O(1)的效果，但是不可避免的会消耗大量的硬件空间，内部空间够用那还好说，如果不够用的话，势必就需要外接储存器，但是MCU和外接储存器通信又要耗费时间，这又有点本末倒置了。那么，有没有折衷的方法呢？答案当然是有的，这就是本文要介绍的CRODIC算法，即坐标旋转数字计算(Coordinate Rotation Digital Computer)。"],"markdown":"CRODIC算法，即坐标旋转数字计算(Coordinate Rotation Digital Computer)，因为其简单的结构，只有移位累加的计算过程，不需要硬件乘法器，没有除法运算，而且CORDIC算法可以计算三角函数，双曲函数，开平方，自然对数等几乎所有的初等函数，纯硬件的实现非常简单，所以该算法被广泛的应用于FPGA平台上。这个算法尤其是在没有硬件乘法器，没有浮点运算单元，Flash空间也很捉急的小型系统中有很大的优势。\n\n# 算法原理\nCORDIC算法的核心其实就是对广义向量旋转进行迭代，由J.D.Volder于1959年首次提出，当时是用来进行三角函数计算的主要算法。1971年Walter.J提出了统一CORDIC算法，将线性和双曲线变换都包括进了CORDIC算法之中，形成目前所用到的CORDIC算法最基本的数学基础。\n\n## 坐标旋转\n![坐标旋转](/img/algorithm-CRODIC/01.png)\n坐标旋转，顾名思义就是将上图中的`(x_1_, y_1_)`旋转`θ`度之后到`(x_2_, y_2_)`的过程。求解过程很简单，这里就略过。解得：\n$$\n\\left\\{\\begin{matrix}\nx_2=x_1\\cdot cos\\theta +y_1\\cdot sin\\theta\\\\\ny_2=x_1\\cdot sin\\theta -y_1\\cdot cos\\theta\n\\end{matrix}\\right.\n$$\n为了方便分析，提出`cosθ`这个公因式，得到：\n$$\n\\left\\{\\begin{matrix}\nx_2=cos\\theta(x_1+y_1\\cdot tan\\theta)\\\\\ny_2=cos\\theta(y_1-x_1\\cdot tan\\theta)\n\\end{matrix}\\right.\n$$\n\n## 二分查找\n![求θ的值](/img/algorithm-CRODIC/02.png)\n二分查找是计算机之中非常有名的算法了，简而言之就是每次都折半进行查找，能够达到O(logn)的时间复杂度，在这里使用二分查找是为了找寻旋转的角度。\n\n为了简单分析，我们只讨论在第一象限的情况，也就是`x > 0 && y > 0`的情况。\n那么很明显的有，$$\\theta=arctan(\\frac{y}{x})$$。\n\nCORDIC的思想非常直接，那就是说如果我们把向量`(x, y)`进行旋转，当旋转到`y=0`的时候，旋转的角度就是`θ`了。\n但是，要如何进行旋转呢？在这里，我们换一个方向来看，实际上`(0°, 90°)`我们可以看作是一个有序的序列，边界条件是`y → 0`，这完全符合二分查找的使用范围。\n利用二分查找的思想，我们可以先让向量顺时针旋转`45°`，代入旋转方程中，得到：\n$$\n\\left\\{\\begin{matrix}\nx'=cos(45^\\circ)(2+3\\cdot tan(45^\\circ))=3.5355\\\\\ny'=cos(45^\\circ)(3-2\\cdot tan(45^\\circ))=0.7071\n\\end{matrix}\\right.\n$$\n可以看到这个时候我们可以发现此时`y > 0`，说明旋转的角度不够，所以继续顺时针旋转，不过这次是旋转`45°/2 = 22.5°`:\n$$\n\\left\\{\\begin{matrix}\nx'=cos(22.5^\\circ)(3.5355+0.7071\\cdot tan(22.5^\\circ))=3.5370\\\\\ny'=cos(22.5^\\circ)(0.7071-3.5355\\cdot tan(22.5^\\circ))=-0.6997\n\\end{matrix}\\right.\n$$\n现在一共旋转了`45° + 22.5° = 67.5°`。可以看到看到此时`y < 0`，说明已经转过头了，现在我们可以逆时针旋转，旋转的角度为`22.5°/2 = 11.25°`：\n$$\n\\left\\{\\begin{matrix}\nx'=cos(11.25^\\circ)(3.5370-(-0.6997)\\cdot tan(11.25^\\circ))=3.6055\\\\ \ny'=cos(11.25^\\circ)(-0.6997+3.5370\\cdot tan(11.25^\\circ))=0.0038\n\\end{matrix}\\right.\n$$\n到现在一共旋转了`67.5° - 11.25° = 56.25°`，可以看到`y`已经非常接近于`0`了，接下来的过程与之类似，就不再演算了。\n\n<p class=\"note\">\n$$arctan(3/2)=56.31^\\circ$$\n</p>\n\n可以发现上面的过程都是重复运算，那当然可以直接写成代码，下面是C语言的实现：\n```c\nint i;\nfloat x = 2.0;\nfloat y = 3.0;\nfloat anglesum = 0.0;\nfloat pi = 3.141592654;\nfloat angle = 45.0/180*pi;\n    \nfor(i = 0; i < 15; i++)\n{\n    if(y < 0)\n    {\n        x_new = cos(angle)*(x - y*tan(angle));\n        y_new = cos(angle)*(y + x*tan(angle));\n        x = x_new;\n        y = y_new;\n        anglesum -= angle;\n    }\n    else\n    {\n        x_new = cos(angle)*(x + y*tan(angle));\n        y_new = cos(angle)*(y - x*tan(angle));\n        x = x_new;\n        y = y_new;\n        anglesum += angle;\n    }\n    angle /= 2;\n}\nanglesum=anglesum*180/pi;\nprintf(\"The ans is %f\\n.\",anglesum);\n\n//The ans is 56.307678.\n```\n\n## 去除公因子\nCORDIC算法的雏形已经有了，但是这个算法实际上非常低效，因为每次迭代都有4次乘法，运算量还是太大了。必须要进行改进。我们再来看看坐标旋转的公式：\n$$\n\\left\\{\\begin{matrix}\nx_2=cos\\theta(x_1+y_1\\cdot tan\\theta)\\\\\ny_2=cos\\theta(y_1-x_1\\cdot tan\\theta)\n\\end{matrix}\\right.\n$$\n每次旋转，x和y都会乘以一个`cos(θ)`，但是实际上我们要求的是$$arctan(\\frac{y}{x})$$。可以看到$$\\frac{y}{x}$$的分子分母都含有`cos(θ)`，这个因式被约掉了。那么，我们也完全可以在计算中就直接不计算`cos(θ)`，得到：\n$$\n\\left\\{\\begin{matrix}\n\\hat{x}_2=x_1-y_1\\cdot tan\\theta\\\\\n\\hat{y}_2=y_1+x_1\\cdot tan\\theta\n\\end{matrix}\\right.\n$$\n很明显的，现在式子中的向量$$(\\hat{x}_2,\\hat{y}_2)$$与原来的向量$$(x_2,y_2)$$是共线的，仅仅是在长度上会有差异。\n\n## 取消乘法\n每次迭代的乘法已经减少了一半，还有没有别的方法呢？\n第一次迭代的时候`tan(45°) = 1`，这是完全不需要乘法的。\n第二次迭代的时候呢？`tan(22.5°) = 0.41421`，很不幸，这是一个小数，小数的乘法运算是不可避免的。但是我们可以看到这个数字很接近于0.5，要是这个数字是0.5的话，一个数乘以0.5，其实就是相当于将这个数右移一位。而单纯的移位操作是非常快速的。而0.5的话，`arctan(0.5) = 26.565`，这个角度比22.5°稍大，这会影响二分查找的效率，但是对于提高运算速度而言绝对是利大于弊的。\n类似的，我们可以在第三次迭代中使用`arctan(0.25) = 14.0362°`，同时乘数右移两位。\n此时，我们已经消除了乘法运算了，但是运算中还有一个`tan`运算，仔细观察我们可以发现，每次迭代我们使用的`tan`的值都是固定的，所以我们完全可以使用函数表的方法来消灭它。\n\n## 定点运算\n定点运算其实就是整数运算，只是需要另外一个数字来进行“定标”，也就是标明小数点在哪一位。也可以理解为通过一个系数将所有的数字放大至整数，用整型进行运算。\n在这里我们将角度标定为定点整数，放大256倍。那么对应下来的理论精度就是`1/256° = 0.00390625°`。在大多数情况下来说都是足够精确的。\n对于其他运算数来说，放大系数取多少没有强制规定，不过一般来说都是越大精度越高，但是一定要考虑到16位（32位）整型数据的上下限。\n下面附上二分查找`arctan`的定点运算数值表：\n\n|序号|度数|x256|取整|\n|:---:|:---|:---|:---|\n|1|45.0|11520|11520|\n|2|26.565051177078|6800.65310133196|6801|\n|3|14.0362434679265|3593.27832778918|3593|\n|4|7.1250163489018|1824.00418531886|1824|\n|5|3.57633437499735|915.541599999322|916|\n|6|1.78991060824607|458.217115710994|458|\n|7|0.8951737102111|229.164469814035|229|\n|8|0.4476141708606|114.589227740302|115|\n|9|0.2238105003685|57.2954880943458|57|\n|10|0.1119056770662|28.647853328949|29|\n|11|0.0559528918938|14.3239403248137|14|\n|12|0.027976452617|7.16197186995294|7|\n|13|0.01398822714227|3.58098614841984|4|\n|14|0.006994113675353|1.79049310089035|2|\n|15|0.003497056850704|0.8952465537802|1|\n\n最终的程序代码如下：\n```c\nint angle[] = {11520, 6801, 3593, 1824, 916,\n\t458, 229, 115, 57, 29, 14, 7, 4, 2, 1};\n\nint i = 0;\nint x, y;\nint y_new = 0,x_new = 0,anglesum = 0;\n\nx = 1024;\ny = (int)(3.0/2.0*1024);  \n//这个数字更大的话，精度会更高；其中3/2是y/x的值\n\nfor(i = 0; i < 15; i++)\n{\n    if(y < 0)\n    {\n        x_new = x - (y >> i);\n        y_new = y + (x >> i);\n        x = x_new;\n        y = y_new;\n        anglesum -=angle[i];\n    }\n    else\n    {\n        x_new = x + (y >> i);\n        y_new = y - (x >> i);\n        x = x_new;\n        y = y_new;\n        anglesum +=angle[i];\n    }\n}\nprintf(\"The ans is %f\\n.\",anglesum);\n\n//The ans is 14420.\n```\n\n由于角度都被放大了256倍，所以它对应实际的角度应该是$$\\frac{14420}{256}=56.328125^\\circ$$。\n\n# CORDIC的推广\n至此，CORDIC的基本原理就介绍完了，但是`arctan`只是CORDIC的一个特例，要将CORDIC扩展到全部的三角函数，甚至于双曲函数，线性函数，还需要统一CORDIC的迭代公式。\n\n## 理论分析\n我们回到最初的圆周坐标旋转公式：\n$$\n\\left\\{\\begin{matrix}\nx_2=cos\\theta(x_1+y_1\\cdot tan\\theta)\\\\\ny_2=cos\\theta(y_1-x_1\\cdot tan\\theta)\n\\end{matrix}\\right.\n$$\n由上述的分析可知，CORDIC实际上就是由向量旋转去逼近真实值的一种算法，那么只要推导出了旋转n次之后的角度通项公式，那么实际就能解出圆周变换中的所有数值。\n我们根据上面的公式，可以进一步推广为：\n$$\n\\left\\{\\begin{matrix}\n\\begin{bmatrix}\nx_n\\\\\ny_n \n\\end{bmatrix}\n=\\prod_{i=1}^{n}cos(\\theta_i)\n\\begin{pmatrix}\n1 & -d_itan(\\theta_i)\\\\\n-d_itan(\\theta_i) & 1\n\\end{pmatrix}\n\\begin{bmatrix}\nx_0\\\\\ny_0\n\\end{bmatrix}\\\\\nz_n=z_0+\\sum_{i=1}^{n}d_i\\theta_i\n\\end{matrix}\\right.\n$$\n其中`d_i_`是指的旋转方向，`d_i_ = -1`示顺时针旋转，`d_i_ = 1`表示逆时针旋转。`θ_i_`是指的当次旋转的角度，`z`是指角度旋转的累加值。\n根据上一节中关于取消乘法的算法，将其中的`tan(θ_i_)`做强制约束，令其等于`2^-i^`，所以就有`θ_i_ = arctan(2^-i^)`。\n由于每次旋转的角度都为预定值，所以`cos(θ_i_)`也是常数，因此若是将此比例常数从迭代方程中去掉，迭代完成后的计算值和实际值的比例关系也必然是常数，并且此时方程中就仅有移位加运算。比例常数和方程的乘积可以在系统的任意部分处理（不一定在CORDIC中完成），或者可以直接作为系统处理的增益。设比例常数为`k_i_`，那么根据方程可以推导出：\n$$\nk_i=\\lim_{n\\rightarrow \\infty }\\prod_{i=0}^{n-1}cos(\\theta_i) =\\lim_{n \\to \\infty }\\prod_{i=0}^{n-1}\\sqrt{1+2^{-2i}}=0.607253\n$$\n去除`k_i_`之后，由系统的通项公式我们可以写出CORDIC圆周变换下的差分方程：\n$$\n\\left\\{\\begin{matrix}\nx_{i+1}=x_i-d_i\\cdot 2^{-i}\\cdot y_i\\\\ \ny_{i+1}=y_i+d_i\\cdot 2^{-i}\\cdot x_i\\\\ \nz_{i+1}=z_i-d_i\\cdot \\theta_i\n\\end{matrix}\\right.\n$$\n其中`d_i_`和前面一样，表示旋转方向。\n\n## 两种旋转模式\n从差分方程中，我们可以看出，CORDIC算法中可以设定的边界条件有三种：\n1. x_n_ → 0\n2. y_n_ → 0\n3. z_n_ → 0\n\n但实际上x_n_→0和y_n_→0是一样的，只是旋转方向不同而已，所以一共有两种旋转模式。其中，y_n_→0被称作`向量模式`；z_n_→0被称做`旋转模式`。\n\n### 向量模式\n此模式下，`d_i_`的符号由`y(i)`来决定，于是有`d_i_ = -sign(y(i))`。\n那么经过n次迭代之后，得到：\n$$\n\\left\\{\\begin{matrix}\nx_n=k_i\\cdot (\\sqrt{x_0^2+y_0^2})\\\\ \ny_n=0\\\\ \nz_n=z_0+arctan(\\frac{y_0}{x_0})\n\\end{matrix}\\right.\n$$\n在向量化模式中，CORDIC将输入的任意向量通过一系列的旋转，最终使向量与`x`轴对齐。向量化的结果为所有旋转角度的累加值，以及输入向量定标后的幅度值（输入向量的模），分量`y`的符号决定下一次的旋转方向，角度累加器初始化值为0，迭代结束后其值为最终旋转的角度值。\n\n### 旋转模式\n此模式下，`d_i_`的符号由`z(i)`来决定，于是有`d_i_ = -sign(z(i))`。\n那么经过n次迭代之后，得到：\n$$\n\\left\\{\\begin{matrix}\nx_n=k_i\\cdot (x_0cos(z_0)-y_0sin(z_0))\\\\\ny_n=k_i\\cdot (y_0cos(z_0)+x_0sin(z_0))\\\\\nz_n=0\n\\end{matrix}\\right.\n$$\n在旋转模式下，角度累加器初始值为需要旋转的角度值。在整个迭代过程中，旋转的方向用语减小角度累加器中剩余的角度值。所以，旋转方向由迭代后剩余角度的符号确定。\n\n## 正弦与余弦\n已知角度求正弦余弦的值，很明显可以使用旋转模式下的CORDIC。如果令旋转的起始向量为：`(1,0)`（即x轴单位向量），输入为角度累加器初始值。带入旋转模式下的迭代公式：\n$$\n\\left\\{\\begin{matrix}\nx_n=k_i\\cdot x_0cos(z_0)\\\\\ny_n=k_i\\cdot x_0sin(z_0)\\\\\nz_n=0\n\\end{matrix}\\right.\n$$\n解得：\n$$\n\\left\\{\\begin{matrix}\ncos(z_0)=\\frac{x_n}{k_i}\\\\ \nsin(z_0)=\\frac{y_n}{k_i}\n\\end{matrix}\\right.\n$$\n\n## 反正切与向量的模\n在上文中已经给出了反正切函数的具体求法，但未给出公式，这里给出反正切函数的迭代公式，具体原理就略过。\n角度累加器初始值为0，使用向量模式，输入即为$$(x_0,y_0)$$，带入向量模式下的迭代公式：\n$$\n\\left\\{\\begin{matrix}\nx_n=k_i\\cdot (\\sqrt{x_0^2+y_0^2})\\\\ \nz_n=arctan(\\frac{y_0}{x_0})\n\\end{matrix}\\right.\n$$\n根据公式可以看出，迭代之后角度累加器的值即是`arctan`。\n由于向量模式下，迭代之后向量与X轴重合，所以这个模式下是可以一并求出原始向量的模的。只是要注意用$$k_i$$标定。\n\n## 反正弦与反余弦\n与`arctan`类似的是，角度累加器初始值为0，但是输入的并不是向量的准确坐标，而是向量的x（或者是y）。\n对于反正弦：设输入为`c`，另旋转的起始向量为：`(1,0)`，边界条件为：y_n_→c，经过n次迭代之后：\n$$\n\\left\\{\\begin{matrix}\nx_n=\\sqrt{(x_0\\cdot k_i)^2-c^2}\\\\ \ny_n=c\\\\ \nz_n=arcsin(\\frac{c}{x_0\\cdot k_i})\n\\end{matrix}\\right.\n$$\n反余弦与之类似，同时反余弦的计算也可以用反正弦函数实现，只需从结果减去`π/2`即可。\n\n## 线性变换：乘与除\n![线性变换](/img/algorithm-CRODIC/03.png)\n线性坐标系下的差分方程可以写为：\n$$\n\\left\\{\\begin{matrix}\nx_{i+1}=x_i-0\\cdot d_i\\cdot 2^{-i}\\cdot y_i=x_i\\\\\ny_{i+1}=y_i+d_i\\cdot 2^{-i}\\cdot x_i\\\\\nz_{i+1}=z_i-d_i\\cdot 2^{-i}\n\\end{matrix}\\right.\n$$\n\n使用`旋转模式`迭代，最终会变成`移位加法器`：\n$$\n\\left\\{\\begin{matrix}\nx_n=x_0\\\\ \ny_n=y_0+x_0\\cdot z_0\n\\end{matrix}\\right.\n$$\n\n使用`向量模式`会变成`比例运算器（除法器）`：\n$$\n\\left\\{\\begin{matrix}\nx_n=x_0\\\\ \ny_n=0\\\\\nz_n=z_0-\\frac{y_0}{x_0}\n\\end{matrix}\\right.\n$$\n\n## 双曲变换：开平方根\n双曲函数和圆周函数有着相似的对应性，所以圆周变换的一些性质也可以应用到双曲变换中来，其中大部分推导过程是相似的，所以这里就不列出推导过程了，顺带介绍一下开根号运算。\n![双曲变换](/img/algorithm-CRODIC/04.png)\n差分方程如下：\n$$\n\\left\\{\\begin{matrix}\nx_{i+1}=x_i+k_n\\cdot (x_0cos(z_0)-y_0sin(z_0))\\\\\ny_{i+1}=y_i+k_n\\cdot (y_0cos(z_0)+x_0sin(z_0))\\\\\nz_{i+1}=z_i-d_i\\cdot arctanh(2^{-i})\n\\end{matrix}\\right.\n$$\n\n`旋转模式`迭代的结果是：\n$$\n\\left\\{\\begin{matrix}\nx_n=k_n\\cdot (x_0\\cdot cosh(z_0)+y_0\\cdot sinh(z_0))\\\\ \ny_n=k_n\\cdot (y_0\\cdot cosh(z_0)+x_0\\cdot sinh(z_0))\\\\\nz_n=0 \n\\end{matrix}\\right.\n$$\n\n其中比例系数为：\n$$\nk_n=\\lim_{n \\to \\infty }\\prod_{i=1}^{n}\\sqrt{1-2^{-2i}}=1.2051\n$$\n\n`向量模式`迭代的结果是：\n$$\n\\left\\{\\begin{matrix}\nx_n=k_n\\sqrt{x_0^2-y_0^2}\\\\ \ny_n=0\\\\\nz_n=z_0+arctanh(y_0/x_0)\n\\end{matrix}\\right.\n$$\n\n看到$$\\sqrt{x_0^2-y_0^2}$$形式，很容易就能想到这个可以用来计算平方根。\n\n设被开平方数为$$x_s$$,则令初始向量为$$(x_s+0.25,x_s-0.25)$$，边界条件为y_n_→0。\n代入向量方程中，化解可得：\n$$\n\\sqrt{x_s}=\\frac{x_n}{k_n}\n$$\n\n## 统一CORDIC\n经过以上的推导，我们已经可以看出，不管是在哪个坐标系下，迭代的形式都是大同小异的，无非就是差了几个正负号而已。而且，关于旋转模式和向量模式也都是通用的，几个坐标系下的计算过程也都是类似的，于是我们可以得出一个统一的CORDIC迭代方程为：\n$$\n\\left\\{\\begin{matrix}\nx_{i+1}=x_i-m\\cdot d_i\\cdot 2^{-i}\\cdot y_i\\\\\ny_{i+1}=y_i+d_i\\cdot 2^{-i}\\cdot x_i\\\\\nz_{i+1}=z_i-d_i\\cdot \\theta_i\n\\end{matrix}\\right.\n$$\n其中：\n$$\n\\theta_i=\\left\\{\\begin{matrix}\narctan(2^{-i})&m=1\\\\ \n2^{-i}&m=0\\\\ \narctanh(-2^{-i})&m=-1\n\\end{matrix}\\right.\n$$\n`m = 1`时为圆周变换，`m = 0`时为线性变换，`m = -1`时为双曲变换。\n$$\nd_i=\\left\\{\\begin{matrix}\nsign(x_i)&Rotating\\\\ \n-sign(y_i)&Vector\n\\end{matrix}\\right.\n$$\n`Rotating`为旋转模式；`Vector`为向量模式。\n\n# 误差分析\n为了进一步分析CORDIC算法的优劣和使用，这里使用Matlab对4种三角函数(sin,tan,asin,atan)以及开根号进行了误差测试，在函数定义域内分成100000个点进行测试，定点放大系数256倍，输入放大系数1024倍。\n\n![sin的误差散点图](/img/algorithm-CRODIC/05.png)\n这是`sin`的绝对误差散点图，它的误差范围为`-0.0019 ≤ Error ≤ 0.0017`。\n\n![tan的误差散点图](/img/algorithm-CRODIC/06.png)\n对于`tan`，由于它在接近`π/2`的时候达到无穷大，而CORDIC算法是达不到的，所以在接近`π/2`的时候误差陡然上升，必须要提出的是，当`Error = 0.02`的时候，角度为`θ=77°`，之后随着角度的增加，误差会越来越大。\n\n![arctan的误差散点图](/img/algorithm-CRODIC/07.png)\n这是`arctan`，误差范围为`-0.0875 ≤ Error ≤ 0.1564`。\n\n![开根号运算的误差散点图](/img/algorithm-CRODIC/08.png)\n对于`开根号`而言，很明显的在`[1,2]`区间内的误差是最小的，达到了小数点后四位的精度，但是面对超出这个范围的数要怎么办呢？可以采用手动缩放的办法，将数字乘以一个已知开方或者是平方数的数字将数字变换到`[1,2]`区间内。\n\n![arcsin的误差散点图](/img/algorithm-CRODIC/09.png)\n最后是`arcsin`，这个函数的精度非常糟糕，我至今不明白为什么会出现这种情况。从图形上来看，很明显误差是近似于一次函数的误差，于是通过分段一次函数对arcsinarcsin进行矫正。下图是矫正之后的误差散点图。\n\n![矫正之后的arcsin误差散点图](/img/algorithm-CRODIC/10.png)\n进行矫正之后，误差比起矫正之前小了一个数量级，但是依旧比较难看，勉强能用就是了……\n\n# 总结\n总的来说，CORDIC算法的理论并不复杂，写成代码之后也只是很短小的一段。但是个人觉得这实在是一个非常有趣的算法，这消除乘法的方法堪称绝妙，非常值得一看。\n从误差上来看，sin、cos、开根号、arctan，这四种算法的误差比较理想，其余的最好还是根据情况酌情使用。","next":{"path":"/post/amplifier-limit","title":"运放限幅电路"},"prev":{"path":"/post/bridge-rectifier","title":"单相桥式整流"}}