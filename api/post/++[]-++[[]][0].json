{"name":"++[]-++[[]][0]","path":"/post/++[]-++[[]][0]","title":"++[] 与 ++[[]][0]","category":"软件设计","date":["2016","10","10"],"tag":["JavaScript","规范"],"layout":"post","toc":[{"tocTitle":"简述","bolt":"BE7AE80E8BFB0"},{"tocTitle":"句法结构","bolt":"BE58FA5E6B395E7BB93E69E84"},{"tocTitle":"[ ]运算符","bolt":"B5B205DE8BF90E7AE97E7ACA6"},{"tocTitle":"++运算符","bolt":"B2B2BE8BF90E7AE97E7ACA6","child":[{"tocTitle":"PutValue()","bolt":"BPutValue--","parent":"B2B2BE8BF90E7AE97E7ACA6"}]},{"tocTitle":"总结","bolt":"BE680BBE7BB93"}],"excerpt":["这是个很有趣的问题，涉及到了JavaScript中很多基本的机制。这两个表达式看起来是一样的，但它们的运行结果却是大相径庭。网上关于它们之间的区别已经有了很多文章，但是我看了很多，却没有一篇能真正说服我，本文是我自己对于这个问题的看法和笔记。"],"next":{"path":"/post/simple-promise","title":"“简单”的Promise"},"prev":{"path":"/post/you-dont-konw-js-zh-ch-02","title":"作用域和闭包"},"content":"<h1 id=\"BE7AE80E8BFB0\">简述</h1><p><span>对于<code>++[[]][0]</code>这个表达式，<code>[]</code>运算符的优先级比<code>++</code>要高，所以首先会运算<code>[[]][0]</code>，这里就是对<code>[[]]</code>数组取下标为<code>0</code>的元素，也就是它内部的<code>[]</code>，所以这个表达式就变成了<code>++[]</code>。但是为什么<code>++[]</code>和<code>++[[]][0]</code>的运行结果却不一样？</span></p><pre class=\"javascript\"><code><ul class=\"gutter\"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li></ul><ul class=\"code\"><li>++[]</li><li><span class=\"hljs-comment\">//Uncaught ReferenceError: Invalid left-hand side expression</span></li><li></li><li>++[[]][<span class=\"hljs-number\">0</span>]</li><li><span class=\"hljs-comment\">//1</span></li></ul></code></pre><p><span>前者抛出了引用错误，而后者却返回了个值，为什么会是这样？</span><span><code>++</code>运算符是自加运算，因此它必须跟着变量而不是常量，所以<code>++[]</code>报错了，这是符合直觉的；然而这并不能解释<code>++[[]][0]</code>为什么没有报错，毕竟<code>[[]][0]</code>这也是个常量啊。</span></p><p><span>先看看这个引用错误<code>ReferenceError</code>，它的说明是<code>Invalid left-hand side expression</code>，也就是<strong>&lt;em&gt;无效的左值表达式&lt;/em&gt;</strong>，这个错误通常并不是运行的时候抛出的，而是在运行前编译阶段抛出的。这就说明这个语句本身是不符合句法规范的。</span></p><p><span>有了这个突破口，我们就先来看看正确的句法规范是怎么样的。</span></p><h1 id=\"BE58FA5E6B395E7BB93E69E84\">句法结构</h1><p><span>首先对这两句话构建语法树，按照成分将它们拆分开来，在这里使用的工具是<code>uglify-js</code>，结果如下：</span></p><pre class=\"javascript\"><code><ul class=\"gutter\"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li><li>11</li><li>12</li><li>13</li><li>14</li><li>15</li><li>16</li><li>17</li><li>18</li><li>19</li><li>20</li><li>21</li><li>22</li><li>23</li><li>24</li><li>25</li><li>26</li><li>27</li><li>28</li><li>29</li><li>30</li><li>31</li><li>32</li><li>33</li><li>34</li><li>35</li><li>36</li><li>37</li><li>38</li><li>39</li><li>40</li><li>41</li><li>42</li><li>43</li><li>44</li><li>45</li></ul><ul class=\"code\"><li><span class=\"hljs-comment\">//语句</span></li><li>++[[]][<span class=\"hljs-number\">0</span>]</li><li><span class=\"hljs-comment\">//语法树</span></li><li>ast = {</li><li>    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"program\"</span>,</li><li>    <span class=\"hljs-attr\">body</span>: [{</li><li>        <span class=\"hljs-attr\">type</span>:<span class=\"hljs-string\">\"ExpressionStatement\"</span>,</li><li>        <span class=\"hljs-attr\">expression</span>: {</li><li>            <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"UpdateExpression\"</span>,</li><li>            <span class=\"hljs-attr\">operator</span>: <span class=\"hljs-string\">\"++\"</span>,</li><li>            <span class=\"hljs-attr\">argument</span>: {</li><li>                <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"MemberExpression\"</span>,</li><li>                <span class=\"hljs-attr\">object</span>: {</li><li>                    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"ArrayExpression\"</span>,</li><li>                    <span class=\"hljs-attr\">elements</span>: [{</li><li>                        <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"ArrayExpression\"</span>,</li><li>                        <span class=\"hljs-attr\">elements</span>: []</li><li>                    }]</li><li>                },</li><li>                <span class=\"hljs-attr\">property</span>: {</li><li>                    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"Literal\"</span>,</li><li>                    <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">0</span></li><li>                }</li><li>            }</li><li>        }</li><li>    }]</li><li>}</li><li></li><li><span class=\"hljs-comment\">//语句</span></li><li>++[]</li><li><span class=\"hljs-comment\">//语法树</span></li><li>ast = {</li><li>    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"program\"</span>,</li><li>    <span class=\"hljs-attr\">body</span>: [{</li><li>        <span class=\"hljs-attr\">type</span>:<span class=\"hljs-string\">\"ExpressionStatement\"</span>,</li><li>        <span class=\"hljs-attr\">expression</span>: {</li><li>            <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"UpdateExpression\"</span>,</li><li>            <span class=\"hljs-attr\">operator</span>: <span class=\"hljs-string\">\"++\"</span>,</li><li>            <span class=\"hljs-attr\">argument</span>: {</li><li>                <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"ArrayExpression\"</span>,</li><li>                <span class=\"hljs-attr\">elements</span>: []</li><li>            }</li><li>        }</li><li>    }]</li><li>}</li></ul></code></pre><p><span><code>++</code>运算符前置的表达式被称做<code>UpdateExpression</code>，而这两句话的主要区别就在于这之内包含的另外的表达式。在<code>++[[]][0]</code>中的表达式被称做<code>MemberExpression</code>，它的意思是对象成员访问；而在<code>++[]</code>中的则是被称做<code>ArrayExpression</code>，它则是数组字面量。</span></p><p><span>接下来，我们来看看规范之中对这些表达式成分的规定。规范中表达式的种类很多，并且它们还能够相互嵌套，看起来很绕。我把它们汇总了起来，并省略掉部分和这里无关的内容，下面就是<code>UpdateExpression</code>表达式中允许的表达式成分列表：</span></p><blockquote><ol><li><p><span>UpdateExpression</span></p></li><li><p><span>LeftHandSideExpression</span></p></li><li><p><span>UnaryExpression</span></p></li><li><p><span>NewExpression</span></p></li><li><p><span>CallExpression</span></p></li><li><p><span>MemberExpression</span></p></li><li><p><span>PrimaryExpression</span></p></li><li><p><span>SuperProperty</span></p></li><li><p><span>MetaProperty</span></p></li><li><p><span>NewTarget</span></p></li><li><p><span>SuperCall</span></p></li><li><p><span>Arguments</span></p></li><li><p><span>ArgumentList</span></p></li></ol></blockquote><p><span>列表的第一个并不是错误，表达式是允许嵌套自己的。</span></p><p><span>对比上面的语法树可以明显的发现，<code>UpdateExpression</code>表达式并不包含<code>ArrayExpression</code>，所以<code>++[]</code>会抛出的语法错误。另外，<code>MemberExpression</code>是归类在<code>Left-Hand-Side Expressions</code>之中的，所以这里的错误名称是<code>Invalid left-hand side expression</code>。</span></p><h1 id=\"B5B205DE8BF90E7AE97E7ACA6\"><code>[ ]</code>运算符</h1><p><span>我们明白了<code>++[]</code>出错是因为不符合JavaScript的语法，但这还不足以打消我们的疑问。虽然<code>++[[]][0]</code>是符合语法的，但它在运行过程中仍然会变成<code>++[]</code>，为什么不会报错呢？</span></p><p><span>这个问题其实很简单，因为JavaScript的语义有两种，静态语义和动态语义，编译的时候检查静态语义以及语法结构，运行时则会使用另外一套语义。</span><span>所以，我们要探究为什么<code>++[[]][0]</code>为什么不会抛出错误，就必须要检查它们的动态语义。</span></p><p><span>运算符<code>[ ]</code>的优先级高于<code>++</code>，所以我们首先就来看看<code>[ ]</code>运算符：</span></p><blockquote><p><span>MemberExpression: MemberExpression <strong>[</strong>Expression<strong>]</strong></span></p><ol><li><p><span>Let baseReference be the result of evaluating MemberExpression.</span></p></li><li><p><span>Let baseValue be ? GetValue(baseReference).</span></p></li><li><p><span>Let propertyNameReference be the result of evaluating Expression.</span></p></li><li><p><span>Let propertyNameValue be ? GetValue(propertyNameReference).</span></p></li><li><p><span>Let bv be ? RequireObjectCoercible(baseValue).</span></p></li><li><p><span>Let propertyKey be ? ToPropertyKey(propertyNameValue).</span></p></li><li><p><span>If the code matched by the syntactic production that is being evaluated is strict mode code, let strict be true, else let strict be false.</span></p></li><li><p><span>Return a value of type Reference whose base value component is bv, whose referenced name component is propertyKey, and whose strict reference flag is strict.</span></p></li></ol></blockquote><p><span>前四步很好理解，就是取出<code>[]</code>左边的<code>MemberExpression</code>，评估并对它求值；然后取出<code>[]</code>里面的<code>Expression</code>，同样的评估和求值。这里的求值运算（<code>GetValue()</code>）有两个含义，对表达式求值，以及取出引用类型变量所引用的对象实例。</span><span>第5步中的<code>RequireObjectCoercible</code>实际上是个类型检查，碰到<code>null</code>和<code>undefined</code>的时候会抛出类型错误，其余情况下直接返回。</span><span>第6步则是把第4步求出来的值转换为对象属性，这是解释器内部的变量类型，专门用来访问对象属性的。</span><span>第7步很明显是判断当前是否是严格模式。</span><span>最后就是返回访问的对象属性值。</span></p><p><span>整个过程很简单，也没有什么奇怪的部分。</span><span>接下来我们看看<code>++</code>运算符，它才是我们关心的重点。</span></p><h1 id=\"B2B2BE8BF90E7AE97E7ACA6\"><code>++</code>运算符</h1><p><span>废话不多说，直接上规范：</span></p><blockquote><p><span>UpdateExpression: ++ UnaryExpression</span></p><ol><li><p><span>Let expr be the result of evaluating UnaryExpression.</span></p></li><li><p><span>Let oldValue be ? ToNumber(? GetValue(expr)).</span></p></li><li><p><span>Let newValue be the result of adding the value 1 to oldValue, using the same rules as for the + operator (see 12.8.5).</span></p></li><li><p><span>Perform ? PutValue(expr, newValue).</span></p></li><li><p><span>Return newValue.</span></p></li></ol></blockquote><p><span>只有短短的5步，前3步没什么好说的，取出表达式评估求值然后<code>+1</code>，这里<code>+1</code>很明显会给<code>[]</code>做隐式类型转换，<code>ToNumber([]) = 0</code>，所以这里的结果就是<code>1</code>。</span><span>然后就是关键的第4步，这里是赋值运算，就是将<code>+1</code>之后的值赋值给表达式的一步。</span><span>按照我们想象的，<code>[]</code>是个常量，这里的赋值必然会失败，但事实告诉我们这里会顺利运行，那么它的过程到底是怎样的呢。</span></p><h2 id=\"BPutValue--\"><code>PutValue()</code></h2><p><span>这里使用的是<code>PutValue()</code>运算，我们来看看它的过程：</span></p><blockquote><p><span>PutValue (V, W)</span></p><ol><li><p><span>ReturnIfAbrupt(V).</span></p></li><li><p><span>ReturnIfAbrupt(W).</span></p></li><li><p><span>If Type(V) is not Reference, throw a ReferenceError exception.</span></p></li><li><p><span>Let base be GetBase(V).</span></p></li><li><p><span>If IsUnresolvableReference(V) is true, then</span></p><ol><li><p><span>If IsStrictReference(V) is true, then</span></p><ol><li><p><span>Throw a ReferenceError exception.</span></p></li></ol></li><li><p><span>Let globalObj be GetGlobalObject().</span></p></li><li><p><span>Return ? Set(globalObj, GetReferencedName(V), W, false).</span></p></li></ol></li><li><p><span>Else if IsPropertyReference(V) is true, then</span></p><ol><li><p><span>If HasPrimitiveBase(V) is true, then</span></p><ol><li><p><span>Assert: In this case, base will never be undefined or null.</span></p></li><li><p><span>Set base to ! ToObject(base).</span></p></li></ol></li><li><p><span>Let succeeded be ? base.[[Set]](GetReferencedName(V), W, GetThisValue(V)).</span></p></li><li><p><span>If succeeded is false and IsStrictReference(V) is true, throw a TypeError exception.</span></p></li><li><p><span>Return.</span></p></li></ol></li><li><p><span>Else base must be an Environment Record,</span></p><ol><li><p><span>Return ? base.SetMutableBinding(GetReferencedName(V), W, IsStrictReference(V)) (see 8.1.1).</span></p></li></ol></li></ol></blockquote><p><span>这个运算是JavaScript引擎中通用的表达式赋值的抽象运算，其中有很多格式检查，所以看起来很长。</span></p><p><span>前两步是内部的语句评估判断，可以不管它。到第三步，这里所谓的<code>Reference</code>是指规范内部的引用类型，而不是常规的七大基本类型中的引用类型，这里的这个引用类型包含了<code>undefined</code>、对象，布尔值，字符串、<code>Symbol</code>值、数字以及变量标识符。<code>[]</code>是个对象，所以这里会顺利通过。</span><span>第4步，<code>GetBase()</code>运算就是取出规范引用类型的基值，这里就是<code>[]</code>。</span><span>第5步，假如<code>V</code>是非法引用，并且是在严格模式下，那么抛出引用错误；<code>V</code>是非法引用，但不是严格模式下，那么会隐式创建全局变量，把这个值赋值给这个新创建的全局变量。<code>[]</code>当然不是非法引用，这里跳过。</span><span>第6步，这里的<code>IsPropertyReference(V)</code>方法会判断输入值的类型，当输入值是对象或者类似对象时返回<code>true</code>。<code>[]</code>是对象，满足条件。</span><span>第6.1步，这里的<code>HasPrimitiveBase(V)</code>是当<code>V</code>布尔值、字符串、Symbol以及数字的时候才会返回<code>true</code>，所以这里跳过。</span><span>第6.2步，这里使用对象内部方法<code>[[Set]]</code>将值<code>W</code>作为了对象的属性值赋值到了<code>V</code>内部。这个值的属性名称则是<code>V</code>的引用名称，这里是规范内部的名称，我们在外面是访问不到的，总之这里的赋值操作是成功的，<code>succeeded = true</code>。</span><span>所以最后跳过6.3步，直接返回。</span></p><p><span>最后回到<code>++</code>运算符最后一步，整个表达式返回新的值，运算结束。</span></p><h1 id=\"BE680BBE7BB93\">总结</h1><p><span>经过上面这么多分析，我觉得可以稍微总结一下了：</span></p><ol><li><p><span><code>++[]</code>的错误是语法错误，在编译阶段就会抛出，而不会等到运行阶段。</span></p></li><li><p><span>动态语义和静态语义的<strong>不同</strong>是造成这个问题的主要原因。</span></p></li></ol><p><span>在最开始我提到了一句：<code>++[]</code>报错符合直觉，而<code>++[[]][0]</code>不报错违反了直觉。</span><span>其实我们再仔细想想就能明白，它们其实都是符合直觉的，不过并不是<strong>我们</strong>的直觉，而是<strong>解释器</strong>的直觉。</span></p><p><span><code>[]</code>是数组字面量，它毫无疑问的是常量，但是<code>[[]][0]</code>呢？我们一眼就看出它也是常量，但是对于解释器却不是如此。我们所谓的<code>一眼</code>其实已经对它进行了运算，求出了这个表达式的结果<code>[]</code>，所以我们下意识的觉得它就是个常量，但是对于解释器却不是如此。在运行前的编译阶段，解释器只会对代码做词法和语法分析，而不会运行代码。</span><span>所以，<code>[[]][0]</code>这个表达式对于解释器来说，其实是个黑箱，解释器并不知道它的结果是常量。因为数组内元素也可以是变量，那么解释器认为这里符合语法也就可以理解了。</span></p><p><span>JavaScript有着相对更灵活的语法，更“动态”的类型，给编程者带来了很多方便的同时，也带来了各种奇奇怪怪的坑。虽然在实际使用中这样的代码几乎不太可能出现，但是研究这类代码的运行机制对于我们理解JavaScript也是有好处的。</span></p>"}