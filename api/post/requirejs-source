{"path":"/post/requirejs-source","name":"requirejs-source","title":"requireJS源码浅析","category":"软件设计","date":["2016","03","17"],"tag":["JavaScript","requireJS","异步"],"layout":"post","toc":"true","excerpt":["初次使用requireJs的时候有很多不甚明了的地方，于是乎就有了看看源码的心思，再加上它的代码加上注释也不过2000+行，而且注释又非常详尽，看起来貌似不怎么困难……我看之前是这么想的……结果发现其实很难……但是半途而废感觉又不太好，还是硬着头皮看了几遍，很多细节问题吃不透，只能理解个大概，本文是我自己的笔记，如果有错误还请指正。另外，本文看着很长，其实有大半都是源码的复制黏贴，水得很……"],"markdown":"# 初始化\n## 主程序入口\n阅读源码首先当然是寻找程序入口，`requireJS`模块的入口便是引用它本身的`<script>`标签。\n```html\n<script src=\"require.js\" data-main=\"lib/main.js\">\n```\n\nJs文件引入之后，模块本身就会被加载，先来看看模块初始化的时候做了什么。\nrequireJS模块的整体结构是一个立即执行函数和3个全局变量：\n```javascript\nvar requirejs, require, define;\n(function (global) {……}(this));\n```\n\n立即执行函数的输入参数是`this`，全局运行的时候this肯定是指向`window`的，那么这个立即执行函数的`global`就是`window`。\n由入口进入之后定义了一大堆变量方法，然后来到了这里，做了第一件事：\n```javascript\n//Create default context.\nreq({});\n```\n\n## 初次运行入口函数\n`req({})`就是初次运行的入口函数，它的函数原型是：\n```javascript\nreq = requirejs = function (deps, callback, errback, optional) {｝\n```\n\n初次运行输入参数是一个空对象，里面的代码只有两句有效（这里就不贴源码了，源码在后面）：\n```javascript\nif (!context) {\n  context = contexts[contextName] = req.s.newContext(contextName);\n}\nif (config) {\n  context.configure(config);\n}\n```\n\n初次运行context是空值，将会运行`newContext()`方法，这个方法很特殊，它只会在初始化的时候运行一次，之后便不会再运行了，但它的代码洋洋洒洒占据了全部代码的三分之二。\n这个方法会不仅是属性参数的初始化，还会创建并在之后持续维护一个闭包，这个闭包保存了几个临时变量。此方法运行没有什么特别的代码，就是一堆工具函数和变量的定义，完成初始化之后，立刻就用空的配置调用了`context.configure`方法初始化了`shim`和`path`等参数。这里面的函数方法之后碰到了再详细说，现在挨个说了也记不住，先找找`data-main`的处理函数。\n\n## 记录用户主程序路径\n再往后就能看到处理`data-main`相关的逻辑了，代码是这样的：\n```javascript\n//Look for a data-main script attribute, \n// which could also adjust the baseUrl.\nif (isBrowser && !cfg.skipDataMain) {\n  //Figure out baseUrl. Get it from the script tag with require.js in it.\n  eachReverse(scripts(), function (script) {\n    //Set the 'head' where we can append children by\n    //using the script's parent.\n    if (!head) {\n      head = script.parentNode;\n    }\n\n    //Look for a data-main attribute to set main script for the page\n    //to load. If it is there, the path to data main becomes the\n    //baseUrl, if it is not already set.\n    dataMain = script.getAttribute('data-main');\n    if (dataMain) {\n      //Preserve dataMain in case it is a path (i.e. contains '?')\n      mainScript = dataMain;\n\n      //Set final baseUrl if there is not already an explicit one,\n      //but only do so if the data-main value is not a loader plugin\n      //module ID.\n      if (!cfg.baseUrl && mainScript.indexOf('!') === -1) {\n        //Pull off the directory of data-main for use as the\n        //baseUrl.\n        src = mainScript.split('/');\n        mainScript = src.pop();\n        subPath = src.length ? src.join('/')  + '/' : './';\n\n        cfg.baseUrl = subPath;\n      }\n\n      //Strip off any trailing .js since mainScript is now\n      //like a module name.\n      mainScript = mainScript.replace(jsSuffixRegExp, '');\n\n      //If mainScript is still a path, fall back to dataMain\n      if (req.jsExtRegExp.test(mainScript)) {\n        mainScript = dataMain;\n      }\n\n      //Put the data-main script in the files to load.\n      cfg.deps = cfg.deps ? cfg.deps.concat(mainScript) : [mainScript];\n\n      return true;\n    }\n  });\n}\n```\n\n因为`requireJS`不止用于浏览器，所以在入口处有一个判断，如果当前是浏览器那么`isBrowser = true`，后面那个暂且不管它。进入之后有一个名为`eachReverse`的方法，它将会逆序遍历传入的第一个参数，而第一个参数是：\n```javascript\nscripts() => document.getElementsByTagName('script');\n```\n\n这里返回了页面中的所有script标签，然后逆序遍历之。这一段代码的含义就是寻找拥有`data-main`属性的标签，并记录主程序入口文件的路径并记录。\n就以我们章节开头的那个标签为例，这里将会保存为——\n```javascript\ncfg = {\n  baseUrl = \"lib/\",\n  deps = [\"main\"]\n}\n```\n\n`cfg.baseUr1`将会保存基础路径，`cfg.deps`将会保存入口文件名。同时`baseUrl`这个属性会被记录到`require.config`中，也就是说如果后续不更改基础路径属性的话，就会默认`data-main`的目录了。\n\n## 第二次运行入口函数\n好了，程序入口已经找到，进入下一个步骤。之后将会再一次运行入口函数，上一次运行入口函数只是初始化，这一次将`cfg`作为参数传入了。\n```javascript\n//Set up with config info.\nreq(cfg);\n```\n\n入口函数`req`的代码如下：\n```javascript\nreq = requirejs = function (deps, callback, errback, optional) {\n\n  //Find the right context, use default\n  var context, config,\n    contextName = defContextName;\n\n  // Determine if have config object in the call.\n  if (!isArray(deps) && typeof deps !== 'string') {\n    // deps is a config object\n    config = deps;\n    if (isArray(callback)) {\n      // Adjust args if there are dependencies\n      deps = callback;\n      callback = errback;\n      errback = optional;\n    } else {\n      deps = [];\n    }\n  }\n\n  if (config && config.context) {\n    contextName = config.context;\n  }\n\n  context = getOwn(contexts, contextName);\n  if (!context) {\n    context = contexts[contextName] = req.s.newContext(contextName);\n  }\n\n  if (config) {\n    context.configure(config);\n  }\n\n  return context.require(deps, callback, errback);\n};\n```\n\n调用`context.configure(config)`保存了输入的`deps`参数之后，再调用`require`。\n之后几个函数来回回调，实际上最后调用的是个名叫`localRequire`的方法，这个方法的源码是这样的：\n```javascript\nfunction localRequire(deps, callback, errback) {\n  var id, map, requireMod;\n\n  if (options.enableBuildCallback && callback && isFunction(callback)) {\n    callback.__requireJsBuild = true;\n  }\n\n  if (typeof deps === 'string') {\n    if (isFunction(callback)) {\n      //Invalid call\n      return onError(\n        makeError(\n          'requireargs', \n          'Invalid require call'\n        ),\n      errback);\n    }\n\n    //If require|exports|module are requested, get the\n    //value for them from the special handlers. Caveat:\n    //this only works while module is being defined.\n    if (relMap && hasProp(handlers, deps)) {\n      return handlers[deps](registry[relMap.id]);\n    }\n\n    //Synchronous access to one module. If require.get is\n    //available (as in the Node adapter), prefer that.\n    if (req.get) {\n      return req.get(context, deps, relMap, localRequire);\n    }\n\n    //Normalize module name, if it contains . or ..\n    map = makeModuleMap(deps, relMap, false, true);\n    id = map.id;\n\n    if (!hasProp(defined, id)) {\n      return onError(makeError('notloaded', 'Module name \"' +\n        id +\n        '\" has not been loaded yet for context: ' +\n        contextName +\n        (relMap ? '' : '. Use require([])')));\n    }\n    return defined[id];\n  }\n\n  //Grab defines waiting in the global queue.\n  intakeDefines();\n\n  //Mark all the dependencies as needing to be loaded.\n  context.nextTick(function () {\n    //Some defines could have been added since the\n    //require call, collect them.\n    intakeDefines();\n\n    requireMod = getModule(makeModuleMap(null, relMap));\n\n    //Store if map config should be applied to this require\n    //call for dependencies.\n    requireMod.skipMap = options.skipMap;\n\n    requireMod.init(deps, callback, errback, {\n      enabled: true\n    });\n\n    checkLoaded();\n  });\n\n  return localRequire;\n}\n```\n\n当`deps`是字符串的情况下，这个`if`里面的东西那先不管，直接看下面。`intakeDefines()`，这个会将两个全局队列清空，这两个全局队列保存的是当前已经引用的全部依赖模块，在调用运行函数的时候会把它们取出，现在里面什么都没有，这里是没什么用的。\n接下来就是重头戏了，`nextTick()`方法实际上是一个延迟函数，源码在这里：\n```javascript\n/**\n * Execute something after the current tick\n * of the event loop. Override for other envs\n * that have a better solution than setTimeout.\n * @param  {Function} fn function to execute later.\n */\nreq.nextTick = typeof setTimeout !== 'undefined' ? function (fn) {\n  setTimeout(fn, 4);\n} : function (fn) { fn(); };\n```\n\n可以看出默认异步延迟了4毫秒，从时间顺序上来说这个异步函数的内容是最后才会运行的。\n它的内容很简单，那就是找出输入的`Module`，在网页上加载这个`module`的`script`标签，值得注意的是加载这个标签是异步的。\n\n## 加载用户主程序\n延迟函数中的程序很简单，只有几句话，首先`intakeDefines()`，取出载入的模块。然后紧接着就是`getModule(makeModuleMap(null, relMap))`。\n先说`makeModuleMap`，它会按照一定的规则生成一个独一无二的对象，规则的具体细节就不说了。然后是`getModule()`，之所以先定义再直接取出是因为要把生成的对象加入到`registry`这个全局变量中，`getModule`的源码很短：\n```javascript\nfunction getModule(depMap) {\n  var id = depMap.id,\n    mod = getOwn(registry, id);\n\n  if (!mod) {\n    mod = registry[id] = new context.Module(depMap);\n  }\n\n  return mod;\n}\n```\n\n**这里能看出预先加载过的模块，之后就不用重新加载了。**\n接下来配置取出的`Moudle`，`deps`存着入口程序的地址。`init()`方法很明显是初始化：\n```javascript\nModule.prototype.init = function (depMaps, factory, errback, options) {\n  options = options || {};\n  //Do not do more inits if already done. Can happen if there\n  //are multiple define calls for the same module. That is not\n  //a normal, common case, but it is also not unexpected.\n  if (this.inited) {\n    return;\n  }\n  this.factory = factory;\n  if (errback) {\n    //Register for errors on this module.\n    this.on('error', errback);\n  } else if (this.events.error) {\n    //If no errback already, but there are error listeners\n    //on this module, set up an errback to pass to the deps.\n    errback = bind(this, function (err) {\n      this.emit('error', err);\n    });\n  }\n  //Do a copy of the dependency array, so that\n  //source inputs are not modified. For example\n  //\"shim\" deps are passed in here directly, and\n  //doing a direct modification of the depMaps array\n  //would affect that config.\n  this.depMaps = depMaps && depMaps.slice(0);\n  this.errback = errback;\n  //Indicate this module has be initialized\n  this.inited = true;\n  this.ignore = options.ignore;\n  //Could have option to init this module in enabled mode,\n  //or could have been previously marked as enabled. However,\n  //the dependencies are not known until init is called. So\n  //if enabled previously, now trigger dependencies as enabled.\n  if (options.enabled || this.enabled) {\n    //Enable this module and dependencies.\n    //Will call this.check()\n    this.enable();\n  } else {\n    this.check();\n  }\n}\n```\n\n这里前面主要是根据实例的内部参数配置参数，关键是最后那个`if`，假如输入参数`option.enabled = true`，那么就会直接调用`this.enable()`，这个方法主要是一些错误检查，无误之后将会跳转到`this.fetch()`方法，源码：\n```javascript\nModule.prototype.fetch = function () {\n  if (this.fetched) {\n    return;\n  }\n  this.fetched = true;\n\n  context.startTime = (new Date()).getTime();\n\n  var map = this.map;\n\n  //If the manager is for a plugin managed resource,\n  //ask the plugin to load it now.\n  if (this.shim) {\n    context.makeRequire(this.map, {\n      enableBuildCallback: true\n    })(this.shim.deps || [], bind(this, function () {\n      return map.prefix ? this.callPlugin() : this.load();\n    }));\n  } else {\n    //Regular dependency.\n    return map.prefix ? this.callPlugin() : this.load();\n  }\n}\n```\n\n这里值得注意的是，有一个`prefix`的参数，这个是当前模块的前置依赖，要是它存在，那么会先加载那个模块，然后再加载当前模块。\n初次调用肯定是不存在的，那么将会继续跳转至`this.load()`，这里面将会把马上就要载入模块的名字和路径当作参数继续跳转，然后将会到达`req.load(context, id, url)`方法，源码很长，但其实都是一些浏览器的兼容处理，最后将会调用`node = req.createNode(config, moduleName, url)`添加标签。你以为完了吗？还没有呢，之后会马上给标签绑定上两个事件：\n```javascript\nnode.addEventListener('load', context.onScriptLoad, false);\nnode.addEventListener('error', context.onScriptError, false);\n```\n\n一个在加载完成后，一个在加载出错时。\n前者是读取新添加脚本的内容，后者是抛出加载错误的异常。\n\n## 加载检查\n当然，不是说添加了`script`标签就完了，肯定要监控脚本是否正常加载了。所以有一个加载检查的函数`checkLoaded()`，虽然源码很长，但是功能挺简单，就不贴代码了，其功能就是间隔50毫秒的异步轮询，如果没有成功加载那么继续监控，如果超过一定时间还未成功，那么就要抛出超时错误。\n至此，终于理顺了初始化过程，对整个 `requirejs`模块的大致解构也有了点初步的了解，接下来看看对外暴露的几个方法。\n\n# require.config\n这个方法会直接调用内部的`req.config()`方法，而后进一步调用`reg()`，将参数保存至内部`context`。但是我比较疑惑的就是它仍然会`require`本身，并制作`Module`，甚至于后面的异步调用都有参与，虽然说是空的`Moudle`，并且未计入全局`Module`列表中，但是程序如此设计不是多此一举吗？\n\n# require\n其实在`requirejs`本身初始化的过程中就是使用这个命令，它不过是将自己作为了一个特殊的模块，初始化首先处理了自己本身的属性，然后`require`了它自己。\n先来介绍一下内部用于保存模块的类——`Module`。\n## `Module`类\n这个类是`requirejs`内部自己定义的类，用于保存依赖的模块，它的原型是这样的：\n```javascript\nModule = function (map) {\n  this.events = getOwn(undefEvents, map.id) || {};\n  this.map = map;\n  this.shim = getOwn(config.shim, map.id);\n  this.depExports = [];\n  this.depMaps = [];\n  this.depMatched = [];\n  this.pluginMaps = {};\n  this.depCount = 0;\n\n  /* this.exports this.factory\n   this.depMaps = [],\n   this.enabled, this.fetched\n   */\n}\n```\n\n每一个依赖都有很多状态，比如`loading`, `enabling`, `defining`，即加载模块文件，使能该模块（运行模块内部的`define`），最后是正在运行`callback`。\n当新建一个模块之后就会立刻运行`init()`，然后根据不同的配置和状态转向不同的方法，比如当前模块的依赖还没有加载，那么就会转向`enable()`，如果依赖加载完毕，那就会转向`check()`，如果状态变成了`defined`，就表示整个模块都运行完了（包括输入的回调）。\n这些状态在初始化的时候并未定义，只有在下面的各个方法中可以看到。\n\n## 具体过程\n对于外部使用而言，其过程和`data-main`初始化大同小异，在这里再稍微提一下。\n对外暴露的`require`会直接调用`req()`方法，根据规则跳过中间那么多处理之后，会转入`localRequire()`，在其中啥事儿没干，就是定义了那个`nextTick()`的异步函数。\n从时间顺序上来讲，脚本读取完成之后将会触发添加脚本时候添加的`load`事件，对于`require`事件而言，也啥都没干……进去跑了一圈就出来了。所以这里也不贴源码了，在`define`有详细介绍。\n间隔几个毫秒之后就是`nextTick()`异步函数，这才是主要的，异步函数中最主要的就是以`enabled: true`为参数初始化，即执行`init()`方法。如果`require`内部有依赖，那么将会保存当前数据，并紧接着去加载它的依赖，有关这一点之后再讲，现在假设没有任何依赖或者说依赖已经加载完成了，有没有完成加载依赖的主要区别都在`Module.check()`函数中，它的源码：\n```javascript\n/**\n * Checks if the module is ready to define itself, and if so,\n * define it.\n */\nModule.prototype.check = function () {\n  if (!this.enabled || this.enabling) {\n    return;\n  }\n\n  var err, cjsModule,\n    id = this.map.id,\n    depExports = this.depExports,\n    exports = this.exports,\n    factory = this.factory;\n\n  if (!this.inited) {\n    // Only fetch if not already in the defQueue.\n    if (!hasProp(context.defQueueMap, id)) {\n      this.fetch();\n    }\n  } else if (this.error) {\n    this.emit('error', this.error);\n  } else if (!this.defining) {\n    //The factory could trigger another require call\n    //that would result in checking this module to\n    //define itself again. If already in the process\n    //of doing that, skip this work.\n    this.defining = true;\n\n    if (this.depCount < 1 && !this.defined) {\n      if (isFunction(factory)) {\n        //If there is an error listener, favor passing\n        //to that instead of throwing an error. However,\n        //only do it for define()'d  modules. require\n        //errbacks should not be called for failures in\n        //their callbacks (#699). However if a global\n        //onError is set, use that.\n        if ((this.events.error && this.map.isDefine) ||\n          req.onError !== defaultOnError) {\n          try {\n            exports = context.execCb(id, factory, depExports, exports);\n          } catch (e) {\n            err = e;\n          }\n        } else {\n          exports = context.execCb(id, factory, depExports, exports);\n        }\n\n        // Favor return value over exports. If node/cjs in play,\n        // then will not have a return value anyway. Favor\n        // module.exports assignment over exports object.\n        if (this.map.isDefine && exports === undefined) {\n          cjsModule = this.module;\n          if (cjsModule) {\n            exports = cjsModule.exports;\n          } else if (this.usingExports) {\n            //exports already set the defined value.\n            exports = this.exports;\n          }\n        }\n\n        if (err) {\n          err.requireMap = this.map;\n          err.requireModules = this.map.isDefine ? [this.map.id] : null;\n          err.requireType = this.map.isDefine ? 'define' : 'require';\n          return onError((this.error = err));\n        }\n\n      } else {\n        //Just a literal value\n        exports = factory;\n      }\n\n      this.exports = exports;\n\n      if (this.map.isDefine && !this.ignore) {\n        defined[id] = exports;\n\n        if (req.onResourceLoad) {\n          var resLoadMaps = [];\n          each(this.depMaps, function (depMap) {\n            resLoadMaps.push(depMap.normalizedMap || depMap);\n          });\n          req.onResourceLoad(context, this.map, resLoadMaps);\n        }\n      }\n\n      //Clean up\n      cleanRegistry(id);\n\n      this.defined = true;\n    }\n\n    //Finished the define stage. Allow calling check again\n    //to allow define notifications below in the case of a\n    //cycle.\n    this.defining = false;\n\n    if (this.defined && !this.defineEmitted) {\n      this.defineEmitted = true;\n      this.emit('defined', this.exports);\n      this.defineEmitComplete = true;\n    }\n\n  }\n}\n```\n\n如果说依赖没有加载完，那么当前`Module`对象必然有`inited = undefined`，所以就会转入`Module.fetch()`方法中去加载依赖，当`inited = true`，那么表示当前`Module`对象加载完成了，可以执行回调，那么将会把参数一股脑传入`context.execCb`函数中，这个函数很短：\n```javascript\nexecCb: function (name, callback, args, exports) {\n    return callback.apply(exports, args);\n}\n```\n\n可以看到，这里就会执行回调了。\n\n# `define`\n再来说说`define`，它的源码其实并不长：\n```javascript\ndefine = function (name, deps, callback) {\n\tvar node, context;\n\n\t//Allow for anonymous modules\n\tif (typeof name !== 'string') {\n\t\t//Adjust args appropriately\n\t\tcallback = deps;\n\t\tdeps = name;\n\t\tname = null;\n\t}\n\n\t//This module may not have dependencies\n\tif (!isArray(deps)) {\n\t\tcallback = deps;\n\t\tdeps = null;\n\t}\n\n\t//If no name, and callback is a function, then figure out if it a\n\t//CommonJS thing with dependencies.\n\tif (!deps && isFunction(callback)) {\n\t\tdeps = [];\n\t\t//Remove comments from the callback string,\n\t\t//look for require calls, and pull them into the dependencies,\n\t\t//but only if there are function args.\n\t\tif (callback.length) {\n\t\t\tcallback\n\t\t\t\t.toString()\n\t\t\t\t.replace(commentRegExp, commentReplace)\n\t\t\t\t.replace(cjsRequireRegExp, function (match, dep) {\n\t\t\t\t\tdeps.push(dep);\n\t\t\t\t});\n\n\t\t\t//May be a CommonJS thing even without require calls, but still\n\t\t\t//could use exports, and module. Avoid doing exports and module\n\t\t\t//work though if it just needs require.\n\t\t\t//REQUIRES the function to expect the CommonJS variables in the\n\t\t\t//order listed below.\n\t\t\tdeps = (callback.length === 1 ? ['require'] : \n\t\t\t\t['require', 'exports', 'module']).concat(deps);\n\t\t}\n\t}\n\n\t//If in IE 6-8 and hit an anonymous define() call, do the interactive\n\t//work.\n\tif (useInteractive) {\n\t\tnode = currentlyAddingScript || getInteractiveScript();\n\t\tif (node) {\n\t\t\tif (!name) {\n\t\t\t\tname = node.getAttribute('data-requiremodule');\n\t\t\t}\n\t\t\tcontext = contexts[node.getAttribute('data-requirecontext')];\n\t\t}\n\t}\n\n\t//Always save off evaluating the def call until the script onload handler.\n\t//This allows multiple modules to be in a file without prematurely\n\t//tracing dependencies, and allows for anonymous module support,\n\t//where the module name is not known until the script onload event\n\t//occurs. If no context, use the global queue, and get it processed\n\t//in the onscript load callback.\n\tif (context) {\n\t\tcontext.defQueue.push([name, deps, callback]);\n\t\tcontext.defQueueMap[name] = true;\n\t} else {\n\t\tglobalDefQueue.push([name, deps, callback]);\n\t}\n}\n```\n\n脚本加载完成之后，就会读取脚本的内容，碰到`define`命令就会运行这里的代码，可以看出`define`命令仅仅是做了很多兼容处理，然后就将所有信息暂存进了两个全局队列。在这里有一处值得注意，就是对`callback`的正则处理，`callback`转为字符串之后连续两次调用`replace()`方法，其中的正则是这样的：\n```javascript\ncommentRegExp = /(\\/\\*([\\s\\S]*?)\\*\\/|([^:]|^)\\/\\/(.*)$)/;\nmgcjsRequireRegExp = /[^.]\\s*require\\s*\\(\\s*[\"']([^'\"\\s]+)[\"']\\s*\\)/g;\n```\n\n上面那个看名字都能看出是匹配代码中的所有注释，后者则是匹配了`require(/*code*/)`这样的结构，并将`require()`内的内容存了起来。很明显了，这里肯定是此模块的依赖，当然要先存起来等待之后加载的。脚本一旦读取完成，就会触发当初添加脚本时候添加的`load`事件，`context.onScriptLoad()`，此事件的源码并不长功能也简单，先是移除了开始给脚本绑定的那两个事件，随后调用了`context.completeLoad()`方法，后者的源码：\n```javascript\ncompleteLoad: function (moduleName) {\n\tvar found, args, mod,\n\t\tshim = getOwn(config.shim, moduleName) || {},\n\t\tshExports = shim.exports;\n\n\ttakeGlobalQueue();\n\n\twhile (defQueue.length) {\n\t\targs = defQueue.shift();\n\t\tif (args[0] === null) {\n\t\t\targs[0] = moduleName;\n\t\t\t//If already found an anonymous module and bound it\n\t\t\t//to this name, then this is some other anon module\n\t\t\t//waiting for its completeLoad to fire.\n\t\t\tif (found) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfound = true;\n\t\t} else if (args[0] === moduleName) {\n\t\t\t//Found matching define call for this script!\n\t\t\tfound = true;\n\t\t}\n\n\t\tcallGetModule(args);\n\t}\n\tcontext.defQueueMap = {};\n\n\t//Do this after the cycle of callGetModule in case the result\n\t//of those calls/init calls changes the registry.\n\tmod = getOwn(registry, moduleName);\n\n\tif (!found && !hasProp(defined, moduleName) && mod && !mod.inited) {\n\t\tif (config.enforceDefine && (!shExports || !getGlobal(shExports))) {\n\t\t\tif (hasPathFallback(moduleName)) {\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\treturn onError(makeError('nodefine',\n\t\t\t\t\t'No define call for ' + moduleName,\n\t\t\t\t\tnull,\n\t\t\t\t\t[moduleName]));\n\t\t\t}\n\t\t} else {\n\t\t\t//A script that does not call define(), so just simulate\n\t\t\t//the call for it.\n\t\t\tcallGetModule([moduleName, (shim.deps || []), shim.exportsFn]);\n\t\t}\n\t}\n\n\tcheckLoaded();\n}\n```\n\n很明显，这里先取出了之前读取文件内容后保存在全局队列中相关的记录，然后调用了`callGetModule()`，它的代码是这样的：\n```javascript\nfunction callGetModule(args) {\n    //Skip modules already defined.\n    if (!hasProp(defined, args[0])) {        \n\t\tgetModule(\n\t\t\tmakeModuleMap(args[0], null, true)).init(args[1], args[2]\n\t\t);    \n\t}\n}\n```\n\n很眼熟吧，在`require`的那个异步函数中也有这么一段，这一段的意思注释也说的很清楚了，就是如果`defined`中已经存了当前模块的信息，说明之前已经加载过啦，就跳过，如果还没有，那就新建一个，并且将之初始化，这个初始化的方法`init()`，在上面也提过了不多讲。\n\n# 依赖的依赖\n在平时的使用中，依赖本身还包含了别的依赖也是很常见的情况。对于这种情况无论是`define`还是`require`处理过程都是一样的，毕竟两个模块都是以`init()`为入口的，所以这里就放在一起讲了。\n还是从`init()`开始，之后将会跳转到`enable()`方法，没有依赖的时候，`enable()`方法几乎不做任何处理就直接跳转到了`check()`方法。\n这里我们当然假设是有依赖的，那么看它的源码：\n```javascript\nModule.prototype.enable = function () {\n\tenabledRegistry[this.map.id] = this;\n\tthis.enabled = true;\n\n\t//Set flag mentioning that the module is enabling,\n\t//so that immediate calls to the defined callbacks\n\t//for dependencies do not trigger inadvertent load\n\t//with the depCount still being zero.\n\tthis.enabling = true;\n\n\t//Enable each dependency\n\teach(this.depMaps, bind(this, function (depMap, i) {\n\t\tvar id, mod, handler;\n\n\t\tif (typeof depMap === 'string') {\n\t\t\t//Dependency needs to be converted to a depMap\n\t\t\t//and wired up to this module.\n\t\t\tdepMap = makeModuleMap(depMap,\n\t\t\t\t(this.map.isDefine ? this.map : this.map.parentMap),\n\t\t\t\tfalse,\n\t\t\t\t!this.skipMap);\n\t\t\tthis.depMaps[i] = depMap;\n\n\t\t\thandler = getOwn(handlers, depMap.id);\n\n\t\t\tif (handler) {\n\t\t\t\tthis.depExports[i] = handler(this);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.depCount += 1;\n\n\t\t\ton(depMap, 'defined', bind(this, function (depExports) {\n\t\t\t\tif (this.undefed) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.defineDep(i, depExports);\n\t\t\t\tthis.check();\n\t\t\t}));\n\n\t\t\tif (this.errback) {\n\t\t\t\ton(depMap, 'error', bind(this, this.errback));\n\t\t\t} else if (this.events.error) {\n\t\t\t\t// No direct errback on this module, but something\n\t\t\t\t// else is listening for errors, so be sure to\n\t\t\t\t// propagate the error correctly.\n\t\t\t\ton(depMap, 'error', bind(this, function(err) {\n\t\t\t\t\tthis.emit('error', err);\n\t\t\t\t}));\n\t\t\t}\n\t\t}\n\n\t\tid = depMap.id;\n\t\tmod = registry[id];\n\n\t\t//Skip special modules like 'require', 'exports', 'module'\n\t\t//Also, don't call enable if it is already enabled,\n\t\t//important in circular dependency cases.\n\t\tif (!hasProp(handlers, id) && mod && !mod.enabled) {\n\t\t\tcontext.enable(depMap, this);\n\t\t}\n\t}));\n\n\t//Enable each plugin that is used in\n\t//a dependency\n\teachProp(this.pluginMaps, bind(this, function (pluginMap) {\n\t\tvar mod = getOwn(registry, pluginMap.id);\n\t\tif (mod && !mod.enabled) {\n\t\t\tcontext.enable(pluginMap, this);\n\t\t}\n\t}));\n\n\tthis.enabling = false;\n\n\tthis.check();\n}\n```\n\n`this. depMaps`就记录着当前模块的依赖，`bind()`函数只是在其中又套了一层函数，不知是为什么，`each()`将会遍历它的第一个输入参数，将它们每一个都做为第二个参数（函数）的参数，然后运行第二个参数（函数）。总之就是用那个回调函数对第一个参数里面的每一个数据都运行一次。\n接下来的挺好懂，`depMap`就是当前依赖的模块名字，根据规则`new Module()`，然后配置之，接下来是`on()`，这个方法代码不长，但是里面套了几层，最后到了这里：\n```javascript\non: function (name, cb) {\n    var cbs = this.events[name];\n    if (!cbs) {\n\t\tcbs = this.events[name] = [];\n    }\n    cbs.push(cb);\n}\n```\n\n简而言之它把后面`bind`里面那个回调函数外带现在的输入参数给存了起来，注意，此时并没有运行。\n随后便是`context.enable()`，这个方法的源码：\n```javascript\nenable: function (depMap) {\n    var mod = getOwn(registry, depMap.id);\n    if (mod) {\n\t\tgetModule(depMap).enable();\n    }\n}\n```\n\n很明显就是加载这个新的依赖。这个新的依赖加载完成之后，依旧触发`completeload()`，然后就取出模块去`init()`，中间的过程省略了，反正最后跳转到了`check()`那里，在这里将会运行它的回调，然后不同的地方在这里，`check()`最后是这样的：\n```javascript\nif (this.defined && !this.defineEmitted) {\n    this.defineEmitted = true;\n    this.emit('defined', this.exports);    \n\tthis.defineEmitComplete = true;\n}\n```\n\n`defined`表示当前依赖的回调已经运行完了，以后都不关它的事儿了，随后将会进`this.emit()`，它的代码是这样的：\n```javascript\nemit: function (name, evt) {\n    each(this.events[name], function (cb) {\n\t\tcb(evt);    \n\t});\n    if (name === 'error') {\n\t\t//Now that the error handler was triggered, remove\n        //the listeners, since this broken Module instance\n        //can stay around for a while in the registry.        \n\t\tdelete this.events[name];\n    }\n}\n```\n\n是不是很眼熟啊，和上面那个`this.on`的代码很像吧，不过刚好反了过来，`this.on`将参数和回调都存了起来，这里就会挨着全部取出来并且依次运行，就这样一层一层的运行。\n\n所以，看明白了吗。简而言之就是加入碰到了需要加载的依赖，会将当前数据全部保存起来，然后去加载新的依赖，直到最后碰到一个不需要加载依赖的模块，此时这个模块将会被首先标记为`initd =  true`，然后执行它的回调，执行完成之后将会从全局变量中依次取出之前的数据，挨个运行回调。\n这个方式很眼熟吧，其实就是递归。`requirejs`调用模块的本质就是递归调用，不过却不是程序自动调用递归，而是完全手动管理的递归调用。之所以要用手工管理，我想大概是因为依赖模块的加载全部都是异步的，不可能用同步的方法阻塞程序运行。也正是因为这种异步+递归的编程思路，让我觉得这个代码实在是比较难以理解……\n\n# 总结\n1. 从编程风格上来说`requirejs`模块的代码虽然少，但是构思非常巧妙，采用了手工管理的递归+异步的编程方式，导致代码理解起来比较困难，再加上其中为了保护内部数据，采用了大量的闭包，无处不在的回调，让我比较头晕。\n2. 从结构上来说，源码中最大的部分就是`newContext()`，这里面定义了一个通用`Module`类，大量的工具函数，并维护了一个存有诸多临时变量的闭包。\n3. 初始化的过程其实就是把`data-main`当作一个特殊的依赖来处理的。\n4. `define`和`require`虽然都是在最后执行回调，但是两者执行的时间其实不一样，`define`是在最后触发`completeload()`事件的最后执行回调，而`require`是在最开始定义的延迟4ms的延迟函数里面执行回调，从事件上来说，`completeload()`事件肯定要早于`require`的异步事件。\n5. 我也只是很浅显的读了读代码，不敢保证完全正确，如果有错误还望指正……另外还有些地方不甚明了，比如`require.config`的那个问题……以后有机会再看吧。以上！","next":{"path":"/post/closures-bind","title":"Function.prototype.bind"},"prev":{"path":"/post/function-dec-exp-ano","title":"函数声明与函数表达式"}}