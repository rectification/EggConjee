title: this和对象原型
category: 你不懂JS
tag: [JavaScript,翻译]
date: 2017-01-28
toc: true
layout: post

---

个人翻译《你不懂JS》系列第三本。这一本书的内容有比较大的争议。
<!--more-->

# 序言
当我为了写序言而阅读这本书的时候，我开始反思当初的我是如何学习JavaScript的，以及在我过去15年的开发和编程的日子中，它改变了多少。
我是在15年前开始使用JavaScript的，那时候在网页中使用非HTML的技术实践（比如CSS和JS）被称作DHTML或者动态HTML。当时JavaScript的效果和现在差别很大，它只能实现诸如在网页中添加雪花动画、动画时钟或者说提示状态栏中的时间这样的效果。可以说在我的职业生涯的早期，我其实并没有怎么重视JavaScript，因为我经常在互联网中发现其他的新奇玩意儿。
这样的情况持续到了2005年，那时我才真正将JavaScript作为一门需要我更加重视的真正的编程语言来看待。在Google地图进入第一个测试版的时候，我就开始关注它的潜力了，当时Google地图是首个同类的应用，它允许你使用鼠标来操作地图，诸如移动、放大、缩小，甚至是无需重新加载页面来发出服务器请求——所有的这些都是靠JavaScript来实现的。这简直像是魔术！
当某个东西看起来像是魔法的时候，这通常是个好迹象，因为这表明你正站在通向某个新生事物的路口上。确实是如此，在今天，JavaScript是我在客户端和服务器端编程的主要语言之一，而且我也没有使用别的方式。
在我过去15年中我有一个遗憾，那就是我没能在2005年之前给JavaScript一个机会，或者更准确的说，我没能看出JavaScript会成为和C++、C#、java等语言一样的真正的编程语言。
如果我在开始职业生涯的时候就能看到《你不懂JS》系列的话，我想我的职业生涯将会和现在大不相同吧。这也是我喜爱这个系列的原因之一：它解释JS的方式非常通俗易懂，并且整个过程非常有趣，干货也非常充足。
《this和对象原型》是该系列非常出色的续集，它非常出色且自然的扩展了前一本书《作用域和闭包》的知识，将之引入了JS语言中非常重要的部分——《this和对象原型》。这两个简单的东西就是你在这本书中学习的关键了，因为它们是使用JavaScript编程真正的基础。在JavaScript中创建大型复杂的应用时，如何创建、关联、扩展对象，都是你必须掌握的知识。没有它们，你将不可能使用JavaScript创建复杂的应用（例如Google地图）。
我会说，绝大多数Web开发人员可能从来没有构建过一个JavaScript对象，只是将该语言作为按钮和AJAX请求之间的事件绑定胶水。我曾经也是如此的，但是当我学会了对象原型的概念以及利用它在JavaScript中创建对象，一个充满可能性的世界为我打开了大门。如果你属于只会创建事件绑定胶水代码的类别，这本书对于你而言是必读的；如果你只是需要复习，这本书将会成为你的复习资料。不管怎样，你绝不会在这里失望。相信我！

Nick Berardi
nickberardi.com, @nberardi

# `this`或者That？
`this`绝对是JavaScript中最混乱的机制之一了。这是个非常特殊的标识符关键字，它在每个函数的作用域内自动定义。但是它到底是什么？即便是经验丰富的JavaScript开发人员也经常会这么问。
> 任何足够先进的技术都与魔法无异。——亚瑟·克拉克

JavaScript中的`this`机制其实并不先进，但是开发人员经常自顾自的就在头脑中自己解释这个东西。毫无疑问，在缺乏清晰理解的情况下，`this`这东西的确挺像魔法的……

<p class="note">
"this"是现代英语中非常常见的代词，因此，如何区分代词的"this"和关键字标识符的"this"非常困难，特别是在口语中。为了清楚起见，我将会使用`this`来引用这个特殊关键字，"this"、*this*、**this**来代替其他意思。
</p>

<p class="translator">
中文就没有这个问题啦，作为程序的`this`关键字会使用像左边这样的格式。
</p>

## 为什么是`this`？
如果`this`机制真的是如此混乱，即便是经验丰富的JavaScript开发人员也会手足无措的话，人们通常会开始对它的价值产生疑问，难道它带来的麻烦远甚于它的价值吗？在我们面对这个问题之前，我们应该先检查一下为什么。

让我们来试着说明下使用`this`的动机以及它的作用：
```JavaScript
function identify() {
    return this.name.toUpperCase();
}

function speak() {
    var greeting = "Hello, I'm " + identify.call( this );
    console.log( greeting );
}

var me = {
    name: "Kyle"
};

var you = {
    name: "Reader"
};

identify.call( me ); // KYLE
identify.call( you ); // READER

speak.call( me ); // Hello, I'm KYLE
speak.call( you ); // Hello, I'm READER
```
`this`机制提供了一种更加优雅的方式来隐式的“传递”对象引用，它能够提供更加简洁的API设计，以及更容易重用。
你使用的编程模式越复杂，你就越会清楚的看到，传递上下文作为一个显示的参数显然要比传递`this`更加麻烦。当我们探索对象和原型的时候，你将会看到一类非常有用的函数，它们将会自动的引用适当的上下文对象。

## 混乱
我们马上就会解释`this`到底是如何工作的，不过在此之前，我们必须消除一些关于它的误解。

首先就在于"this"这个名称本身。开发者总是试图从字面意义上来理解它，在业界通常有两个非常常见的错误：

### 它自己
第一个看起来非常合理的假设是，`this`指代的是当前函数本身。
但是为什么要从函数内部来引用它自己？最常见的情况是递归，或者是个只会运行一次的事件处理函数，首次运行之后将之解除绑定。
开发者通常会认为这个机制的作用就是，将函数引用为一个对象（在JavaScript中，所有函数都是对象！），然后允许在函数调用之间储存状态（属性中的值）。虽然这种机制是可以可以实现的，并且也确实有一定的用途，但这并不是`this`的工作范围。另外，在本书的其它部分，我将会阐述许多其他的模式，它们能够更好的实现上述关于储存函数对象状态的设想。
不过，我们还是先来看看这种模式，以说明这个假设是错误的，`this`并不会得带函数本身的引用。

考虑下面的代码，我们试图跟踪一个函数（`foo`）被调用的次数：
```JavaScript
function foo(num) {
    console.log( "foo: " + num );

    // keep track of how many times `foo` is called
    this.count++;
}

foo.count = 0;

var i;

for (i=0; i<10; i++) {
    if (i > 5) {
        foo( i );
    }
}
// foo: 6
// foo: 7
// foo: 8
// foo: 9

// how many times was `foo` called?
console.log( foo.count ); // 0 -- WTF?
```
即便这里的四个`console.log`语句清楚的表示了这个函数被调用了四次，但是`foo.count`一直是`0`。这个结果明白的告诉了我们，从字面意义上来理解`this`是错误的。
当代码执行`foo.count = 0`的时候，实际上它像函数对象`foo`添加了一个`count`属性。但是对于`this.count`这个在函数内部的引用来说，`this`实际上并不是指向函数对象，因此即使是属性名称相同，但是根对象是不同的，这就引起了混乱。

<p class="note">
一个负责的开发者应该问这一点：“如果我给某个对象添加了`count`属性，但它其实并不是我需要的那个，那么我添加的`count`属性到底在哪里？”事实上，如果她深入挖掘，她会发现她不小心创建了一个全局变量`count`（见第二章，到底发生了什么！），它的当前值为`NaN`。当然，当她发现这个奇怪的结果之后，她马上就会问出另一个问题：“它怎么会是全局变量？为什么最终它的值会是`NaN`，而不是适当的计数值？（见第二章）”
</p>

深入挖掘这个并没有实行预期行为的`this`引用的原因，并回答上述这些艰难但重要的问题。许多开发人员完全回避了这个问题，它们开始讨论一些其他的解决方案，比如创建另一个对象来保存`count`属性的值：
```JavaScript
function foo(num) {
    console.log( "foo: " + num );

    // keep track of how many times `foo` is called
    data.count++;
}

var data = {
    count: 0
};

var i;

for (i=0; i<10; i++) {
    if (i > 5) {
        foo( i );
    }
}
// foo: 6
// foo: 7
// foo: 8
// foo: 9

// how many times was `foo` called?
console.log( data.count ); // 4
```
虽然这种方式的确“解决”了这个问题，但不幸的是，它仅仅是忽略了真正的问题——缺乏对`this`的意义以及它是如何工作的，这一事实的理解——然后回到了我们更加熟悉的领域：词法作用域。

<p class="note">
词法作用域是个非常优美且有用的机制；我不会用任何方式来轻视它（见系列标题“作用域和闭包”）。在你不断猜测如何去使用`this`的过程中，肯定经常会碰到各种错误，但这并不是你继续使用词法作用域的理由，如果你始终这样逃避的话，那你永远也学不会`this`。
</p>



原文链接：https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch1.md