title: CRODIC算法简析
category: 软件设计
date: 2014-09-25
tag: [C,数值求解,算法]
layout: post
toc: true

---

初等函数是数值计算里老生常谈的话题了，现在最常用的办法无非就是泰勒展开、切比雪夫逼近等等方法。计算精度是有的，但是全浮点的运算，在一些低廉的硬件系统之中仍然受到了很大的限制，邪道点的方法比如直接打表hash查找，虽然时间上达到了O(1)的效果，但是不可避免的会消耗大量的硬件空间，内部空间够用那还好说，如果不够用的话，势必就需要外接储存器，但是MCU和外接储存器通信又要耗费时间，这又有点本末倒置了。那么，有没有折衷的方法呢？答案当然是有的，这就是本文要介绍的CRODIC算法，即坐标旋转数字计算(Coordinate Rotation Digital Computer)。
<!--more-->

CRODIC算法，即*坐标旋转数字计算(Coordinate Rotation Digital Computer*)，因为其简单的结构，只有移位累加的计算过程，不需要硬件乘法器，没有除法运算，而且CORDIC算法可以计算三角函数，双曲函数，开平方，自然对数等几乎所有的初等函数，纯硬件的实现非常简单，所以该算法被广泛的应用于FPGA平台上。这个算法尤其是在没有硬件乘法器，没有浮点运算单元，Flash空间也很捉急的小型系统中有很大的优势。

# 算法原理
CORDIC算法的核心其实就是对广义向量旋转进行迭代，由J.D.Volder于1959年首次提出，当时是用来进行三角函数计算的主要算法。1971年Walter.J提出了统一CORDIC算法，将线性和双曲线变换都包括进了CORDIC算法之中，形成目前所用到的CORDIC算法最基本的数学基础。

## 坐标旋转
![坐标旋转](/img/algorithm-CRODIC/01.png)
坐标旋转，顾名思义就是将上图中的 *(x_1_, y_1_)* 旋转`θ`度之后到 *(x_2_, y_2_)* 的过程。求解过程很简单，这里就略过。解得：
$$
\left\{\begin{matrix}
x_2=x_1\cdot cos\theta +y_1\cdot sin\theta\\
y_2=x_1\cdot sin\theta -y_1\cdot cos\theta
\end{matrix}\right.
$$
为了方便分析，提出`cosθ`这个公因式，得到：
$$
\left\{\begin{matrix}
x_2=cos\theta(x_1+y_1\cdot tan\theta)\\
y_2=cos\theta(y_1-x_1\cdot tan\theta)
\end{matrix}\right.
$$

## 二分查找
![求θ的值](/img/algorithm-CRODIC/02.png)
二分查找是计算机之中非常有名的算法了，简而言之就是每次都折半进行查找，能够达到O(logn)的时间复杂度，在这里使用二分查找是为了找寻旋转的角度。

为了简单分析，我们只讨论在第一象限的情况，也就是`x > 0 && y > 0`的情况。
那么很明显的有，$$\theta=arctan(\frac{y}{x})$$。

CORDIC的思想非常直接，那就是说如果我们把向量`(x, y)`进行旋转，当旋转到`y=0`的时候，旋转的角度就是`θ`了。
但是，要如何进行旋转呢？在这里，我们换一个方向来看，实际上`(0°, 90°)`我们可以看作是一个有序的序列，边界条件是`y → 0`，这完全符合二分查找的使用范围。
利用二分查找的思想，我们可以先让向量顺时针旋转`45°`，代入旋转方程中，得到：
$$
\left\{\begin{matrix}
x'=cos(45^\circ)(2+3\cdot tan(45^\circ))=3.5355\\
y'=cos(45^\circ)(3-2\cdot tan(45^\circ))=0.7071
\end{matrix}\right.
$$
可以看到这个时候我们可以发现此时`y > 0`，说明旋转的角度不够，所以继续顺时针旋转，不过这次是旋转`45°/2 = 22.5°`:
$$
\left\{\begin{matrix}
x'=cos(22.5^\circ)(3.5355+0.7071\cdot tan(22.5^\circ))=3.5370\\
y'=cos(22.5^\circ)(0.7071-3.5355\cdot tan(22.5^\circ))=-0.6997
\end{matrix}\right.
$$
现在一共旋转了`45° + 22.5° = 67.5°`。可以看到看到此时`y < 0`，说明已经转过头了，现在我们可以逆时针旋转，旋转的角度为`22.5°/2 = 11.25°`：
$$
\left\{\begin{matrix}
x'=cos(11.25^\circ)(3.5370-(-0.6997)\cdot tan(11.25^\circ))=3.6055\\ 
y'=cos(11.25^\circ)(-0.6997+3.5370\cdot tan(11.25^\circ))=0.0038
\end{matrix}\right.
$$
到现在一共旋转了`67.5° - 11.25° = 56.25°`，可以看到`y`已经非常接近于`0`了，接下来的过程与之类似，就不再演算了。

<p class="note">
$$arctan(3/2)=56.31^\circ$$
</p>

可以发现上面的过程都是重复运算，那当然可以直接写成代码，下面是C语言的实现：
```c
int i;
float x = 2.0;
float y = 3.0;
float anglesum = 0.0;
float pi = 3.141592654;
float angle = 45.0/180*pi;
    
for(i = 0; i < 15; i++)
{
    if(y < 0)
    {
        x_new = cos(angle)*(x - y*tan(angle));
        y_new = cos(angle)*(y + x*tan(angle));
        x = x_new;
        y = y_new;
        anglesum -= angle;
    }
    else
    {
        x_new = cos(angle)*(x + y*tan(angle));
        y_new = cos(angle)*(y - x*tan(angle));
        x = x_new;
        y = y_new;
        anglesum += angle;
    }
    angle /= 2;
}
anglesum=anglesum*180/pi;
printf("The ans is %f\n.",anglesum);

//The ans is 56.307678.
```

## 去除公因子
CORDIC算法的雏形已经有了，但是这个算法实际上非常低效，因为每次迭代都有4次乘法，运算量还是太大了。必须要进行改进。我们再来看看坐标旋转的公式：
$$
\left\{\begin{matrix}
x_2=cos\theta(x_1+y_1\cdot tan\theta)\\
y_2=cos\theta(y_1-x_1\cdot tan\theta)
\end{matrix}\right.
$$
每次旋转，x和y都会乘以一个`cos(θ)`，但是实际上我们要求的是$$arctan(\frac{y}{x})$$。可以看到$$\frac{y}{x}$$的分子分母都含有`cos(θ)`，这个因式被约掉了。那么，我们也完全可以在计算中就直接不计算`cos(θ)`，得到：
$$
\left\{\begin{matrix}
\hat{x}_2=x_1-y_1\cdot tan\theta\\
\hat{y}_2=y_1+x_1\cdot tan\theta
\end{matrix}\right.
$$
很明显的，现在式子中的向量$$(\hat{x}_2,\hat{y}_2)$$与原来的向量$$(x_2,y_2)$$是共线的，仅仅是在长度上会有差异。

## 取消乘法
每次迭代的乘法已经减少了一半，还有没有别的方法呢？
第一次迭代的时候`tan(45°) = 1`，这是完全不需要乘法的。
第二次迭代的时候呢？`tan(22.5°) = 0.41421`，很不幸，这是一个小数，小数的乘法运算是不可避免的。但是我们可以看到这个数字很接近于0.5，要是这个数字是0.5的话，一个数乘以0.5，其实就是相当于将这个数右移一位。而单纯的移位操作是非常快速的。而0.5的话，`arctan(0.5) = 26.565`，这个角度比22.5°稍大，这会影响二分查找的效率，但是对于提高运算速度而言绝对是利大于弊的。
类似的，我们可以在第三次迭代中使用`arctan(0.25) = 14.0362°`，同时乘数右移两位。
此时，我们已经消除了乘法运算了，但是运算中还有一个`tan`运算，仔细观察我们可以发现，每次迭代我们使用的`tan`的值都是固定的，所以我们完全可以使用函数表的方法来消灭它。

## 定点运算
定点运算其实就是整数运算，只是需要另外一个数字来进行“定标”，也就是标明小数点在哪一位。也可以理解为通过一个系数将所有的数字放大至整数，用整型进行运算。
在这里我们将角度标定为定点整数，放大256倍。那么对应下来的理论精度就是`1/256° = 0.00390625°`。在大多数情况下来说都是足够精确的。
对于其他运算数来说，放大系数取多少没有强制规定，不过一般来说都是越大精度越高，但是一定要考虑到16位（32位）整型数据的上下限。
下面附上二分查找`arctan`的定点运算数值表：

|序号|度数|x256|取整|
|:---:|:---|:---|:---|
|1|45.0|11520|11520|
|2|26.565051177078|6800.65310133196|6801|
|3|14.0362434679265|3593.27832778918|3593|
|4|7.1250163489018|1824.00418531886|1824|
|5|3.57633437499735|915.541599999322|916|
|6|1.78991060824607|458.217115710994|458|
|7|0.8951737102111|229.164469814035|229|
|8|0.4476141708606|114.589227740302|115|
|9|0.2238105003685|57.2954880943458|57|
|10|0.1119056770662|28.647853328949|29|
|11|0.0559528918938|14.3239403248137|14|
|12|0.027976452617|7.16197186995294|7|
|13|0.01398822714227|3.58098614841984|4|
|14|0.006994113675353|1.79049310089035|2|
|15|0.003497056850704|0.8952465537802|1|

最终的程序代码如下：
```c
int angle[] = {11520, 6801, 3593, 1824, 916,
	458, 229, 115, 57, 29, 14, 7, 4, 2, 1};

int i = 0;
int x, y;
int y_new = 0,x_new = 0,anglesum = 0;

x = 1024;
y = (int)(3.0/2.0*1024);  
//这个数字更大的话，精度会更高；其中3/2是y/x的值

for(i = 0; i < 15; i++)
{
    if(y < 0)
    {
        x_new = x - (y >> i);
        y_new = y + (x >> i);
        x = x_new;
        y = y_new;
        anglesum -=angle[i];
    }
    else
    {
        x_new = x + (y >> i);
        y_new = y - (x >> i);
        x = x_new;
        y = y_new;
        anglesum +=angle[i];
    }
}
printf("The ans is %f\n.",anglesum);

//The ans is 14420.
```

由于角度都被放大了256倍，所以它对应实际的角度应该是$$\frac{14420}{256}=56.328125^\circ$$。

# CORDIC的推广
至此，CORDIC的基本原理就介绍完了，但是`arctan`只是CORDIC的一个特例，要将CORDIC扩展到全部的三角函数，甚至于双曲函数，线性函数，还需要统一CORDIC的迭代公式。

## 理论分析
我们回到最初的圆周坐标旋转公式：
$$
\left\{\begin{matrix}
x_2=cos\theta(x_1+y_1\cdot tan\theta)\\
y_2=cos\theta(y_1-x_1\cdot tan\theta)
\end{matrix}\right.
$$
由上述的分析可知，CORDIC实际上就是由向量旋转去逼近真实值的一种算法，那么只要推导出了旋转n次之后的角度通项公式，那么实际就能解出圆周变换中的所有数值。
我们根据上面的公式，可以进一步推广为：
$$
\left\{\begin{matrix}
\begin{bmatrix}
x_n\\
y_n 
\end{bmatrix}
=\prod_{i=1}^{n}cos(\theta_i)
\begin{pmatrix}
1 & -d_itan(\theta_i)\\
-d_itan(\theta_i) & 1
\end{pmatrix}
\begin{bmatrix}
x_0\\
y_0
\end{bmatrix}\\
z_n=z_0+\sum_{i=1}^{n}d_i\theta_i
\end{matrix}\right.
$$
其中`d_i_`是指的旋转方向，`d_i_ = -1`示顺时针旋转，`d_i_ = 1`表示逆时针旋转。`θ_i_`是指的当次旋转的角度，`z`是指角度旋转的累加值。
根据上一节中关于取消乘法的算法，将其中的`tan(θ_i_)`做强制约束，令其等于`2^-i^`，所以就有`θ_i_ = arctan(2^-i^)`。
由于每次旋转的角度都为预定值，所以`cos(θ_i_)`也是常数，因此若是将此比例常数从迭代方程中去掉，迭代完成后的计算值和实际值的比例关系也必然是常数，并且此时方程中就仅有移位加运算。比例常数和方程的乘积可以在系统的任意部分处理（不一定在CORDIC中完成），或者可以直接作为系统处理的增益。设比例常数为`k_i_`，那么根据方程可以推导出：
$$
k_i=\lim_{n\rightarrow \infty }\prod_{i=0}^{n-1}cos(\theta_i) =\lim_{n \to \infty }\prod_{i=0}^{n-1}\sqrt{1+2^{-2i}}=0.607253
$$
去除`k_i_`之后，由系统的通项公式我们可以写出CORDIC圆周变换下的差分方程：
$$
\left\{\begin{matrix}
x_{i+1}=x_i-d_i\cdot 2^{-i}\cdot y_i\\ 
y_{i+1}=y_i+d_i\cdot 2^{-i}\cdot x_i\\ 
z_{i+1}=z_i-d_i\cdot \theta_i
\end{matrix}\right.
$$
其中`d_i_`和前面一样，表示旋转方向。

## 两种旋转模式
从差分方程中，我们可以看出，CORDIC算法中可以设定的边界条件有三种：
1. x_n_ → 0
2. y_n_ → 0
3. z_n_ → 0

但实际上x_n_→0和y_n_→0是一样的，只是旋转方向不同而已，所以一共有两种旋转模式。其中，y_n_→0被称作`向量模式`；z_n_→0被称做`旋转模式`。

### 向量模式
此模式下，`d_i_`的符号由`y(i)`来决定，于是有`d_i_ = -sign(y(i))`。
那么经过n次迭代之后，得到：
$$
\left\{\begin{matrix}
x_n=k_i\cdot (\sqrt{x_0^2+y_0^2})\\ 
y_n=0\\ 
z_n=z_0+arctan(\frac{y_0}{x_0})
\end{matrix}\right.
$$
在向量化模式中，CORDIC将输入的任意向量通过一系列的旋转，最终使向量与`x`轴对齐。向量化的结果为所有旋转角度的累加值，以及输入向量定标后的幅度值（输入向量的模），分量`y`的符号决定下一次的旋转方向，角度累加器初始化值为0，迭代结束后其值为最终旋转的角度值。

### 旋转模式
此模式下，`d_i_`的符号由`z(i)`来决定，于是有`d_i_ = -sign(z(i))`。
那么经过n次迭代之后，得到：
$$
\left\{\begin{matrix}
x_n=k_i\cdot (x_0cos(z_0)-y_0sin(z_0))\\
y_n=k_i\cdot (y_0cos(z_0)+x_0sin(z_0))\\
z_n=0
\end{matrix}\right.
$$
在旋转模式下，角度累加器初始值为需要旋转的角度值。在整个迭代过程中，旋转的方向用语减小角度累加器中剩余的角度值。所以，旋转方向由迭代后剩余角度的符号确定。

## 正弦与余弦
已知角度求正弦余弦的值，很明显可以使用旋转模式下的CORDIC。如果令旋转的起始向量为：`(1,0)`（即x轴单位向量），输入为角度累加器初始值。带入旋转模式下的迭代公式：
$$
\left\{\begin{matrix}
x_n=k_i\cdot x_0cos(z_0)\\
y_n=k_i\cdot x_0sin(z_0)\\
z_n=0
\end{matrix}\right.
$$
解得：
$$
\left\{\begin{matrix}
cos(z_0)=\frac{x_n}{k_i}\\ 
sin(z_0)=\frac{y_n}{k_i}
\end{matrix}\right.
$$

## 反正切与向量的模
在上文中已经给出了反正切函数的具体求法，但未给出公式，这里给出反正切函数的迭代公式，具体原理就略过。
角度累加器初始值为0，使用向量模式，输入即为$$(x_0,y_0)$$，带入向量模式下的迭代公式：
$$
\left\{\begin{matrix}
x_n=k_i\cdot (\sqrt{x_0^2+y_0^2})\\ 
z_n=arctan(\frac{y_0}{x_0})
\end{matrix}\right.
$$
根据公式可以看出，迭代之后角度累加器的值即是`arctan`。
由于向量模式下，迭代之后向量与X轴重合，所以这个模式下是可以一并求出原始向量的模的。只是要注意用$$k_i$$标定。

## 反正弦与反余弦
与`arctan`类似的是，角度累加器初始值为0，但是输入的并不是向量的准确坐标，而是向量的x（或者是y）。
对于反正弦：设输入为`c`，另旋转的起始向量为：`(1,0)`，边界条件为：y_n_→c，经过n次迭代之后：
$$
\left\{\begin{matrix}
x_n=\sqrt{(x_0\cdot k_i)^2-c^2}\\ 
y_n=c\\ 
z_n=arcsin(\frac{c}{x_0\cdot k_i})
\end{matrix}\right.
$$
反余弦与之类似，同时反余弦的计算也可以用反正弦函数实现，只需从结果减去`π/2`即可。

## 线性变换：乘与除
![线性变换](/img/algorithm-CRODIC/03.png)
线性坐标系下的差分方程可以写为：
$$
\left\{\begin{matrix}
x_{i+1}=x_i-0\cdot d_i\cdot 2^{-i}\cdot y_i=x_i\\
y_{i+1}=y_i+d_i\cdot 2^{-i}\cdot x_i\\
z_{i+1}=z_i-d_i\cdot 2^{-i}
\end{matrix}\right.
$$

使用`旋转模式`迭代，最终会变成`移位加法器`：
$$
\left\{\begin{matrix}
x_n=x_0\\ 
y_n=y_0+x_0\cdot z_0
\end{matrix}\right.
$$

使用`向量模式`会变成`比例运算器（除法器）`：
$$
\left\{\begin{matrix}
x_n=x_0\\ 
y_n=0\\
z_n=z_0-\frac{y_0}{x_0}
\end{matrix}\right.
$$

## 双曲变换：开平方根
双曲函数和圆周函数有着相似的对应性，所以圆周变换的一些性质也可以应用到双曲变换中来，其中大部分推导过程是相似的，所以这里就不列出推导过程了，顺带介绍一下开根号运算。
![双曲变换](/img/algorithm-CRODIC/04.png)
差分方程如下：
$$
\left\{\begin{matrix}
x_{i+1}=x_i+k_n\cdot (x_0cos(z_0)-y_0sin(z_0))\\
y_{i+1}=y_i+k_n\cdot (y_0cos(z_0)+x_0sin(z_0))\\
z_{i+1}=z_i-d_i\cdot arctanh(2^{-i})
\end{matrix}\right.
$$

`旋转模式`迭代的结果是：
$$
\left\{\begin{matrix}
x_n=k_n\cdot (x_0\cdot cosh(z_0)+y_0\cdot sinh(z_0))\\ 
y_n=k_n\cdot (y_0\cdot cosh(z_0)+x_0\cdot sinh(z_0))\\
z_n=0 
\end{matrix}\right.
$$

其中比例系数为：
$$
k_n=\lim_{n \to \infty }\prod_{i=1}^{n}\sqrt{1-2^{-2i}}=1.2051
$$

`向量模式`迭代的结果是：
$$
\left\{\begin{matrix}
x_n=k_n\sqrt{x_0^2-y_0^2}\\ 
y_n=0\\
z_n=z_0+arctanh(y_0/x_0)
\end{matrix}\right.
$$

看到$$\sqrt{x_0^2-y_0^2}$$形式，很容易就能想到这个可以用来计算平方根。

设被开平方数为$$x_s$$,则令初始向量为$$(x_s+0.25,x_s-0.25)$$，边界条件为y_n_→0。
代入向量方程中，化解可得：
$$
\sqrt{x_s}=\frac{x_n}{k_n}
$$

## 统一CORDIC
经过以上的推导，我们已经可以看出，不管是在哪个坐标系下，迭代的形式都是大同小异的，无非就是差了几个正负号而已。而且，关于旋转模式和向量模式也都是通用的，几个坐标系下的计算过程也都是类似的，于是我们可以得出一个统一的CORDIC迭代方程为：
$$
\left\{\begin{matrix}
x_{i+1}=x_i-m\cdot d_i\cdot 2^{-i}\cdot y_i\\
y_{i+1}=y_i+d_i\cdot 2^{-i}\cdot x_i\\
z_{i+1}=z_i-d_i\cdot \theta_i
\end{matrix}\right.
$$
其中：
$$
\theta_i=\left\{\begin{matrix}
arctan(2^{-i})&m=1\\ 
2^{-i}&m=0\\ 
arctanh(-2^{-i})&m=-1
\end{matrix}\right.
$$
`m = 1`时为圆周变换，`m = 0`时为线性变换，`m = -1`时为双曲变换。
$$
d_i=\left\{\begin{matrix}
sign(x_i)&Rotating\\ 
-sign(y_i)&Vector
\end{matrix}\right.
$$
`Rotating`为旋转模式；`Vector`为向量模式。

# 误差分析
为了进一步分析CORDIC算法的优劣和使用，这里使用Matlab对4种三角函数(sin,tan,asin,atan)以及开根号进行了误差测试，在函数定义域内分成100000个点进行测试，定点放大系数256倍，输入放大系数1024倍。

![sin的误差散点图](/img/algorithm-CRODIC/05.png)
这是`sin`的绝对误差散点图，它的误差范围为`-0.0019 ≤ Error ≤ 0.0017`。

![tan的误差散点图](/img/algorithm-CRODIC/06.png)
对于`tan`，由于它在接近`π/2`的时候达到无穷大，而CORDIC算法是达不到的，所以在接近`π/2`的时候误差陡然上升，必须要提出的是，当`Error = 0.02`的时候，角度为`θ=77°`，之后随着角度的增加，误差会越来越大。

![arctan的误差散点图](/img/algorithm-CRODIC/07.png)
这是`arctan`，误差范围为`-0.0875 ≤ Error ≤ 0.1564`。

![开根号运算的误差散点图](/img/algorithm-CRODIC/08.png)
对于`开根号`而言，很明显的在`[1,2]`区间内的误差是最小的，达到了小数点后四位的精度，但是面对超出这个范围的数要怎么办呢？可以采用手动缩放的办法，将数字乘以一个已知开方或者是平方数的数字将数字变换到`[1,2]`区间内。

![arcsin的误差散点图](/img/algorithm-CRODIC/09.png)
最后是`arcsin`，这个函数的精度非常糟糕，我至今不明白为什么会出现这种情况。从图形上来看，很明显误差是近似于一次函数的误差，于是通过分段一次函数对arcsinarcsin进行矫正。下图是矫正之后的误差散点图。

![矫正之后的arcsin误差散点图](/img/algorithm-CRODIC/10.png)
进行矫正之后，误差比起矫正之前小了一个数量级，但是依旧比较难看，勉强能用就是了……

# 总结
总的来说，CORDIC算法的理论并不复杂，写成代码之后也只是很短小的一段。但是个人觉得这实在是一个非常有趣的算法，这消除乘法的方法堪称绝妙，非常值得一看。
从误差上来看，sin、cos、开根号、arctan，这四种算法的误差比较理想，其余的最好还是根据情况酌情使用。