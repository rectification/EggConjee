title: Up & Going
category: 你不懂JS
tag: [JavaScript,翻译]
date: 2016-08-02
toc: true
layout: post

---

个人翻译《你不懂JS》系列第一本。说是第一本，但是从写作顺序上来说却并不是第一本，这个系列首先完成的是第二本《作用域与闭包》，这本书更像是为了凑成完整的系列而写的。说它是“凑数”的，并不是说它写的不好，这本书的质量也是很高的。不过，本书也只是编程（JavaScript）的入门书，如果你已经很了解JavaScript了，那么这本书你可以直接翻到第三章，看看系列后面的概要。
<!--more-->

# 序言

你还记得你学到的最后一个新东西是什么吗？
也许它是一门像意大利语或德语那样的外语，或者也许它是一个像 Photoshop那样的图形编辑器，又或者是烹饪技术、木工、健身。我希望你能想起当你终于理解了它时那一瞬的感觉（脑补下小灯泡特效），当一切从模糊变得清晰，当你掌握或是理解了法语的阳性和阴性名词之间的区别。那种感觉怎么样？非常爽，对吧？
现在我希望你回想一下你在学习到这个新技能的前一刻，那时候感觉如何？可能稍微有点害怕也许还有点令人沮丧，对吗？虽然现在我们明白了，而且完全理解了，但是在某一时刻，我们对这一无所知，我们每一个人都是从这“某一时刻”开始的。学习新事物是一场激动人心的冒险，特别是当你正在飞速学习的时候。
我教过非常多的初级代码学习班，在那些班级中，总有很多学生通过阅读博客文章或者复制黏贴代码来自学HTML或JavaScript。他们确实是通过代码达到了自己的目标，但事实上他们并没有真正掌握这些材料。因为他们并没有抓住这些代码的重点，他们并不理解这些代码运行的时候发生了什么，以至于他们无法调试，也无法编写功能强大的代码。
在我的班级中，我讲解web标准(web standards)、语义标记(semantic markup)、注释良好的代码和其他最佳做法，我始终相信我的教学方法是正确的。我的课题中自始自终都有一个主线，那就是要知其然更要知其所以然，绝不仅仅是复制黏贴代码，更要知道怎样去写以及为什么要这么写。当你努力理解你的代码的时候，你将能更好的创造和完成你的工作，到那时，代码将不只是你的工作，你的技能。这也是为什么我喜欢Up & Going的原因。Kyle^注^在这本书中将会深入的讲解javascript的语法和各种术语，这本书绝不会仅仅是点到即止，它将让我们真正了解我们即将写下的各种概念。

<p class="translator">
Kyle Simpson，本书作者。
</p>

我们可以复制jQuery代码片段到您的网站中，也同样可以了解到如何打开、关闭，并把文档保存在Photoshop中。同样的，当我们学习到了几个基本程序，我也能创造和分享我自己的设计了。但是，如果不理解这些工具背后的原理，我如何才能定义网格（原文grid，不知到底是指的什么），如何才能制定一个清晰的类型系统，又或者优化用于web的图形？不知道循环如何工作，如何定义变量，什么是作用域，我们绝对写不出最好的代码。我们并不想像这样敷衍塞责——毕竟，这是我们自己的手艺。
对于JavaScript，你接触的越多，它也将变得越清晰。闭包、对象和方法可能现在还超出了你的理解范围，但这本书将帮助你清晰地理解它们。我希望你能想起当你学习某个新事物时的两种感觉，也许它看起来有点可怕，但是既然你已经翻开了这本书，那就读下去吧，我的朋友，Up & Going将会成为我们理解编程之路的起点，享受那灯泡被点亮的时刻吧！

Jenn Lukas
jennlukas.com, @jennlukas
前端顾问


# 前言

## 前言
在互联网发展的早期，围绕着我们消费的各种内容，为了推动我们的互动体验，JavaScript就已经成为了其中的基础技术，JavaScript的历史就是从那些闪烁的鼠标轨迹以及烦人的弹出提示框开始的。近20年，JavaScript的技术和性能增长了好几个数量级，而网络也已经成为了世界上最广泛最重要的的软件平台，其中JavaScript实在是功不可没。
但是，作为一种语言来说，它一直饱受批评，这其中部分原因是源自它的历史包袱，而更多的则是因为它本身的设计哲学有问题。Brendan Eich^注^曾经说过，JavaScript甚至连名字都给人一种像是紧邻着较为成熟的大哥“Java”那不起眼的哑巴弟弟一般。之所以取名叫“JavaScript”其实是市场营销方面的原因，Java和JavaScript这两种语言在很多重要方面大不相同，它们的关系就好比是“雷峰”和“雷锋塔”一样。

<p class="translator">
Brendan Eich，JavaScript的设计者，JavaScript语言是他花了十来天搞出来的。
</p>

因为JavaScript借用了好几种语言的理念和语法，其中包括了大量C风格的过程式编程，以及不太明显的Scheme/Lisp风格的函数式编程，这样的设计对于广大开发者甚至是那些很少或者几乎没有编程经验的人来说，都是非常熟悉和简单的。JavaScript非常吸引人，而且能够在学习的初期就能很容易感受到编程的舒适感，它的“Hello World”实在是太简单了。
虽然JavaScript可能是最早出现的语言之一，但是由于其本身的特殊性，相比其他语言，能真正掌握JavaScript的人比较少。如果想用C、C++这样的语言编写功能全面的程序，那需要对语言有很深的了解。但是对于JavaScript来说，编写功能全面的程序仅仅是冰山一角。
JavaScript语言总是趋向于使用表面上看起来简单的方式，而将内部的复杂变化隐藏起来了。比如回调函数。因此很多JavaScript开发者只是使用语言，而并不会关心在引擎内部发生了什么。
它是个简单且易于使用的语言，它具有广泛的普及度，但同时它也有着复杂和细致的语言机制，以至于即便是对于最有经验的JavaScript开发者，如果不仔细的学习，也将会很难真正理解它。
这就是JavaScript的矛盾之处，就像阿喀琉斯之踵一样的矛盾之处，这也是我们现在面临的挑战。JavaScript可以不求甚解的使用，然而理解这门语言真的很难，你真的敢说自己完全理解了它吗？

## 目标
在你学习JavaScript的过程中，如果你碰到意外或者挫折的的反应是将其拖入黑名单从此再不理会，用不了多久你就会把JavaScript语言真正的多样性全部排除。
剩下的部分就是非常著名的“好的部分”^注^，但是亲爱的读者们，我再次呼吁大家将这些部分称作“简单的部分”、“安全的部分”，甚至是“不完整的部分”。

<p class="translator">
所谓“好的部分”，在这里特指 Douglas Crockford 写的《JavaScript语言精粹》。
</p>

《你不懂JS》系列提供了一个完全相反的挑战：学习以及深入理解所有的JavaScript，特别是那些“艰难的部分”。
在本书中，我们要直面当前JavaScript开发者不求甚解的大趋势，他们往往不会深入理解语言内部的机制，遇到困难就会退缩。我们要做的恰好相反，不是退缩，而是继续前进。
我从来都不会感到满足，我希望你也能如此。不满足于只是让代码正常工作，而是想要弄清楚“为什么”。我希望你能勇于挑战这条崎岖颠簸的“人迹罕至的道路”，拥抱整个JavaScript。掌握了这些知识之后，无论什么技术、框架和流行词语你都能轻松理解。
JavaScript语言有一些非常核心的概念，但是这些概念又经常被误解，本系列书籍将会围绕这些概念进行深入的介绍，你在读书的时候应当有着绝对能理解的信心，不仅仅是为了了解这些理论，更是为了明确“我需要知道是什么”。
不管你之前是通过怎样的方法学习了JavaScript，那些都只是真正语言的影子，学完这个系列之后，你就会掌握真正的JavaScript。读下去吧，我的朋友，JavaScript恭候你的光临。

## 概要
JavaScript是非常了不起的，它有很容易就能学习的部分，但是却很难完全掌握。当开发者们遇到困惑，他们通常会责备语言，而不会想到其实是他们自己不理解。这个系列书籍就是为了解决这个问题，你现在就能够，也应该深入的去了解这些令人鼓舞的语言特性。
<p class="note">
书中的很多例子都是假设运行在现代JavaScript运行环境中，比如ES6。在一些老环境（ES6之前的）中运行可能会出现一些问题。
</p>

# 第一章：编程初见

欢迎来到《你不懂JS(YDKJS)》系列。
《Up & Going》会介绍一些关于编程的基本概念，当然我们将会特别关注JavaScript（通常缩写为JS），对于这个系列剩下几本书标题所代表的内容，我们也将在这本书中学习如何接近与理解他们。尤其是如果你刚刚进入编程或者JavaScript领域，这本书将会简要探讨为了变得Up & Going你需要什么。
这本书将会从一个很高的层次出发，解释编程的基本原理。本书的主要目的就是为了那些几乎没有任何编程经验的读者，通过JavaScript这个镜头来帮助他们理解程序设计。
第一章是个快速的概述，你将通过学习它以及随后的练习来进入编程的世界。其中还有很多精彩的程序资源，它们能够帮助你深入理解这些概念，而且我鼓励你在本章之外学习它们。
一旦你觉得你已经掌握了编程的基础，第二章将会帮助引导你熟悉JavaScript的特点。第二章介绍了什么是JavaScript，但是它不是权威指南——这是YDKJS这本书剩下的部分的内容！
如果你已经能够相当熟练地使用JavaScript，那么请你首先翻到第三章，简单看看你想要从YDNJS中得到什么，然后直接去翻阅你需要的部分吧！

## 代码

让我们开始吧。一个程序，通常被称作源代码或者代码，它通过一组特殊的指令，告诉计算机执行什么任务。虽然用JavaScript可以直接输入代码到浏览器的控制台中，但一般而言，代码都是保存在一个文本文件中的，稍后我们将打开控制台。
由有效的格式以及指令的组合规则被称为计算机语言，有时也被称作语法，它和英语很相似，告诉你如何拼写单词，如何用单词和标点创建有效的语句。

### 语句

在计算机语言中，执行特定任务的一组单词、数字以及运算符就叫做“语句”。在JavaScript中，语句可能看起来像是这样：

```javascript
a = b * 2;
```

这里的a和b都被称作`变量`（阅读“变量”），他们就像是个能让你存储任何东西的小盒子一样。在程序中，变量存储着供程序使用的值（像是数字42）。它们被认为是那些值的象征性占位符本身。
相比之下，2仅仅是值本身，它被称作`字面量(literal value)`，因为它孤零零的，并没有被变量储存起来。
`=`和`*`被称作运算符（阅读“运算符”）——它们对值和变量们执行赋值和数学运算。
大多数JavaScript语句都以分号(;)宣告结束。
`a = b * 2;`这个语句告诉了计算机，得到现在储存在变量b中的值，然后把它和2相乘，最后把计算的结果储存到另一个变量a中。
程序就是像刚才那样的语句的集合，它们一起描述了你的程序所要达到目标的所有步骤。

### 表达式
语句是由一个或者多个表达式组成的，表达式则是引用了变量或者值，又或者是由运算符组合起来的变量（们）和值（们）。
比如：

```javascript
a = b * 2;
```

这个语句包含了四个表达式：
* `2`是字面量表达式
* `b`是变量表达式，意味着检索当前它保存的值
* `b * 2`是`算术表达式`，这里是乘法
* `a = b * 2`是赋值表达式，将`b * 2`表达式的结果赋值给变量a。

假如表达式是单独存在的，那么它将会被称作表达式语句，像这样：

```javascript
b * 2;
```

表达式语句在程序中并不是很常见，因为它一般没有任何作用，也不会对运行的程序有任何影响——它仅仅是检索了b的值，然后把它和2相乘，但是并没有对它的结果做任何事情。
更常见的表达式语句是调用函数（阅读“函数”），整个语句就是函数调用表达式本身：

```javascript
alert( a );
```

### 执行程序

如何才能让这些集合语句高速计算机做什么？该程序需要被执行，这也被称作运行程序。
像`a = b * 2`这样的语句有助于开发者阅读和写作，但其实计算机并不能直接理解它们。所以在计算机里还有特别作用的程序（解释器或者编译器）用于将您写的代码转换为计算机可以理解的命令。
对于某些计算机语言，这样的翻译命令是每次运行程序的时候自顶向下逐行进行的，这样的行为被称作`解释型语言`。
还有其他的语言，它们的翻译都是提前完成的，这样的被称做`编译型语言`。所以，当程序运行的时候，其实它运行的已经是编译好的计算机能够理解的指令了。
可以肯定的是，JavaScript是`解释型语言`，因为你的JavaScript代码每次运行的时候都会被处理。但这也并不完全准确，JavaScript引擎在运行代码前都会飞快的编译你的代码，然后立刻运行这些编译之后的代码。
<p class="note">
关于JavaScript编译更详细的信息，请阅读本系列的《作用域和闭包》的前两章。
</p>

## 自己尝试一下
本章将会通过一些简单的代码片段介绍每个编程的概念，当然，它们全都会用JavaScript编写。
在这里我想重点强调下面几句话：当你学习这章的时候——你可能需要花费些时间来复习几次——在学习这些概念的时候，你应该要自己上手去练习。做到这一点最简单的方法就是打开离你最近的浏览器（Firefox,Chrome,IE），打开它的开发者工具控制台！
<p class="note">通常你可以用键盘快捷键或者是从菜单选项中打开控制台。有关在你喜欢的浏览器中如何起动控制台，请阅读"[Mastering The Developer Tools Console](http://blog.teamtreehouse.com/mastering-developer-tools-console)" 。在控制台中想要一次键入多行，请使用`<shift>`+`<enter>`移动到下一行，一旦你碰到了`<enter>`，控制台将运行你刚才输入的一切。
</p>

让我们熟悉一下在控制台中运行代码的过程。首先，我建议在您的浏览器中打开一个空的选项卡，我更喜欢在在地址栏中输入`"about:blank"`。然后，请确保您的开发人员控制台就像刚才我们提到的那样打开着。
现在，让我们键入下列代码，看看它是如何运行的：

```javascript
a = 21;
b = a * 2;
console.log( b );
```

在Chrome的控制台中，键入的代码将会产生如下的输出：
![CHrome控制台输出](/img/up-going/01.png)
来吧，尝试一下。学习编程最好的方法就是写代码！

### 输出
在刚才的代码片段中，我们使用了`console.log(..)`。让我们简明扼要的说说那一行代码是什么。
你可能已经猜到了，这就是我们在开发者控制台打印文本（即输出给用户）的方法。这个语句有两个特点，我们马上就解释。
首先，`log(b)`这部分被称作函数调用（阅读“函数”）。我们把变量b交给了那个函数，那个函数拿到了这个值然后将它输出到了控制台中。
然后，`console.`部分是一个对象引用，`log(..)`函数就在其中。我们对于对象的属性和细节的详细讲解在第二章。
创建输出还有另外一个方法，那就是使用`alert(..)`。比如这样：

```javascript
alert(b);
```

假如你运行了它，你会注意到它将会弹出一个有“ok”选项以及变量b内容的对话框。不过，通常情况下都是使用`console.log(..)`，在控制台中使用`console.log(..)`比`alert(..)`要好很多，因为使用`alert(..)`输出时，它将会中断程序运行。
在这本书中，我们将都使用`console.log(..)`输出。

### 输入
当我们都在讨论输出的时候，你可能还想了解输入（即从用户接收信息）。
最常见的方式是在HTML页面中显示表单元素（显示文本输入框），用户可以在那里输入，然后使用JS读取这些值到程序的变量中。
但是还有一个更简单的方法，在简单的学习和演示输入的时候，而且你也会在学习这本书的时候用上它。使用`prompt(..)`函数：

```javascript
age = prompt( "Please tell me your age:" );
console.log( age );
```

你可能已经猜到了，`prompt(..)`将会给你传递一个消息——在这里是`"Please tell me your age:"`——将之打印在弹出窗口中。
它看起来应该和下面这个很相似：
![CHrome控制台输入](/img/up-going/02.png)
一旦你点击了“ok”，提交输入文本，你键入的值将会存储在age变量中，然后我们再用`console.log(..)`输出：
![CHrome控制台输入](/img/up-going/03.png)
在我们学习这些基础的程序片段的时候，为了让程序显得简短一点，这本书中的示例将不会再需要输入。但是现在你已经看到了如何使用`prompt(..)`，如果你想要挑战自己，你可以尝试在你自己的例子中使用输入。

## 运算符
我们想要对值和变量执行什么动作，这就要靠运算符了。我们已经见到了两个JavaScript的运算符了，`=`和`*` 。
`*`运算符执行数学上的乘法运算，够简单的吧？
`=`运算符用于赋值操作——我们首先计算`=`右边的值（来源值），然后把这个值赋值给左侧的变量中（目标变量）。
警告：这似乎有点奇怪，看起来和我们平常的顺序相反。对于a = 42，有些人可能更喜欢将它翻转过来，让来源值在左边，目标变量在右边，像是42 –> a（这在JavaScript中是非法的！）。不幸的是，a = 42或者是其类似的变化是一种固定的命令形式，如果你感觉有点不自然，你只需要花一点时间适应它。
像这样：

```javascript
a = 2;
b = a + 1;
```

在这里，我们将2这个值赋值给了a变量。然后，我们用变量a的值（仍然是2）加上了1，结果等于3，最后把这个值存储到了变量b中。
从技术上讲，你需要在每个程序中使用关键字`var`，因为它是你声明（即创建）变量的主要方式（阅读“变量”）。
在你使用它之前，你应该总是直接通过名字来声明变量，但是，一旦你在每一个作用域（阅读“作用域”）中声明了一次某个变量，以后你可以无限次的使用它。比如这样：

```javascript
var a = 20;
a = a + 1;
a = a * 2;
console.log( a );   // 42
```

这里我们介绍一下在JavaScript中很常见的运算符：
* 赋值：`=`，比如 a = 2
* 数学：`+`加，`-`减，`*`乘，`/`除，比如 a * 3
* 复合赋值： `+=`，`-=`，`*=`，`/=`，它们是结合了数学运算的赋值运算，比如 a += 2（等同于a = a + 2）
* 自增/自减：`++`自增，`--`自减，比如 a++（类似于 a = a + 1）
* 对象属性访问：`.`，比如执行console.log()。在被称作“属性”的特定命名位置中存储着各种各样的值，这样的值的集合也是一个值，而这个值就被称作对象。Obj.a就是一个被称作obj的对象值中名为a的属性。属性也可以通过其他方式访问，比如obj[‘a’]，阅读第二章。
* 等于：`==`等于，`===`严格等于，`!=`不等于，`!==`严格不等于，比如a == b
  阅读“第二章 值与类型”
* 比较：`<`小于，`>`大于，`<=`小于或等于，`>=`大于或等于，比如a <= b
  阅读“第二章 值与类型”
* 逻辑：`&&`逻辑与，`||`逻辑或，比如a||b，这里的意思是选择a或者是b
  这些运算符可以用来表示复合条件（阅读“条件语句”），比如，if either a or b is true.

<p class="note">
还有很多细节和运算符在这里并没有提及，请参考这里[表达式和运算符](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Expressions_and_Operators)。
</p>

## 值与类型

假如你在手机商店里问某个手机的价钱，而对方回答说“99.99”，对方给了你的这个实际的数字代表着你如果要买一个这个手机需要付出的金额，如果你想要购买两个手机，那么你当然可以轻松的心算得到199.98数字，这是你刚才花费金额的两倍。
假如同样的员工拿起了另一个类似的电话，但是这次他表示这个是“免费”，这个时候他们并没有给你一个确切的数字，而是给了你一个具有代表您预期成本（0.00）的词语——“免费”。
你之后询问道，这个手机是否包含充电器，这个答案就只可能是“yes”或者“no”了。
和上面的过程非常相似，当你在程序中表达各种值的时候，你将会首先计划好要拿这些值去做什么，然后基于这些计划选择不同的表达方式去表现这些值。这些值的不同的表达形式在编程术语中被称作`类型`。JavaScript给这些原始值内置了一些基础类型：
* 当你需要做一些数学运算的时候，你需要`Number`
* 当你需要在屏幕上打印一个值的时候，你需要`String`（一个或者多个字符、单词、句子）
* 当你需要在程序中做决定的时候，你需要`Boolean`（true或者false）

直接包含在源代码中的值被称做`字面量`。`字符串字面量`是被双引号(“…”)或者单引号包围起来的(‘…’)——双单引号唯一的区别就是文本风格的偏好。`数字字面量`和`布尔字面量`就是像刚才提出的那样（42等等，true等等）。
比如：

```javascript
"I am a string";
'I am also a string';

42;

true;
false;
```

在`string/number/boolean`之外还有很多类型，常见的编程语言大都会提供它们，比如`Array`（数组），`Object`（对象），`Function`（函数）等等。我们将在下一章详细讲解这些它们。

### 类型转换
假如你有一个数字，但是需要把它打印到屏幕上，你需要把这个值转换为字符串，在JavaScript中，这个转换的过程被称做`强制类型转换`（coercion）。类似的，比如有人在商务电子网页中表单中输入了一系列数字，这是个字符串，但是假如你需要使用这些值去做数学运算，那么你就需要把这些值强制转换为数字。
JavaScript提供了很多不同的方法来进行不同类型之间的强制转换。比如：

```javascript
var a = "42";
var b = Number(a);
console.log(a);   	// "42"
console.log( b );   // 42
```

就像我们看到的那样，使用`Number(..)`（一个内建函数）可以把其他任何类型强制转换为数字，这应当是相当简单的。
当你试图去比较两个不同类型的值的时候，会发生什么？这是一个备受争议的话题。
当你比较字符串”99.99”和数字99.99的时候，大部分人都会同意它们是相等的。但是它们并不完全一样，对吧？它们两个有着相同的值，但是却使用了两种不同的表现形式，两种类型，你可以说它们是“不严格相等”的，可以吗？
在这些常见的情况下，JavaScript为了帮助你，它有时将会使用隐式类型转换来匹配类型。
假如你使用==（不严格等于）运算符去比较`”99.99”==99.99`，JavaScript将会把左边的”99.99”转换为数字99.99，然后，这个比较再比较99.99==99.99，这当然是正确的。
虽然它的意图是为了帮助你，但是如果你不花时间去学习控制其行为的规则，那么隐式类型转换将会造成开发上的混乱。大多数JS开发人员很少去研究它，所以它们普遍感觉隐士类型转换是令人困惑的，会危害程序以及发生意想不到的错误，因此应该尽量避免。在语言设计中，它甚至会被称作缺陷。
然而，隐式类型转换是一种可以学习的机制，如果你希望认真对待JavaScript编程，那么你就应该去学习它，一旦你学会了它的规则，它不仅不会令人混乱，而且还会让你的程序变得更好，这种努力是值得的！
<p class="note">
关于类型转换更多的信息，请阅读第二章的值与类型，以及本系列的《类型和语法》的第四章。
</p>

## 代码注释
手机店的员工可能会记下一些笔记，比如新公布的手机的功能亦或是员工的公司提供了新的计划。这些说明只是给员工自己看的——它们并不会给客户阅读。这些笔记会帮助员工更好的工作，这些笔记将会告诉他应该告诉客户什么，以及为什么这么做。
编程并不仅仅是给计算机编程，这是你在这门课程中你能学习到的最重要的事情之一。Code is every bit as much, if not more, for the developer as it is for the compiler.
你的计算机只会关心从编译器送来的0和1这样的机器码。在未来的日子中，你也能写出近乎无穷的程序吧。你选择如何写程序的问题——这不仅仅是只对你，更是对你所在团队的其他成员，甚至是未来的你自己的问题。
你不应该只是为了让程序代码正常工作，更应该让代码在检查的时候变得更有意义。比如说你可以给变量和函数取一些更好的更容易理解的名字。
编程另一个非常重要的部分就是代码的注释。这些只是纯粹在程序中插入的文本，编译器/解释器将会直接忽略掉这部分内容，所以你可以在注释中写下你对正常程序代码的解释和注解。
对于如何写下良好的注释有着很多种方案，我们在这里真的不能定义下一个绝对的普遍规则，但是这里有一些有用的意见和准则：
* 没有注释的代码是不理想的
* 注释太多了（比如一行一个）也可能是代码写的很差的标志
* 注释最好是解释“为什么”，而不是说明是“什么”。当然也可以选择性的说明一些实在是很困难的事情。

在JavaScript中，注释有两种：单行注释和多行注释。
像这样：

```javascript
// This is a single-line comment
/* But this is      
     a multiline             
     	comment.                      
				*/
```

如果你打算在正上方或者是行末添加注释，那么这样的单行注释是合适的。在//后面直到行末的一切都将会被视为注释（会被编译器忽略），单行注释中没有限制里面可能出现的任何东西^注^。
<p class="translator">
这句话实在是比较拗口，其实就是说单行注释里面什么都能写，完全没有限制的意思。
</p>

像这样：

```javascript
var a = 42;     // 42 is the meaning of life/
/*…*/
```

如果你想解释的事情需要好几句话才能说清楚，那么使用多行注释是合适的。下面是个多行注释的例子：

```javascript
/* The following value is used because
it has been shown that it answers
every question in the universe. */
var a = 42;
```

因为`*/`代表着注释的结束，所以它可以出现在单独的一行，甚至在代码中间，例如：

```javascript
var a = /* arbitrary value */ 42;
console.log( a );   // 42
```

在多行注释中唯一不能出现的就是`*/`，因为它意味这注释的结束。
你一定希望通过学习注释代码的习惯出发，开始学习编程。在本章的其余部分，你将会看到我用注释解释代码，所以在你自己的实践中做同样的事情吧。相信我，大家在读到你的代码的时候都会感谢你的！

<p class="translator">
想到一个笑话。说，程序员最讨厌的两件事情是什么？一个是给自己的程序写注释；还有一个就是看别人的代码，但是那份代码没有注释。
</p>

## 变量
具有实用性的程序通常都需要跟踪一个值，这个值在你的程序的预定任务中，经历了各种不同的运算符，也发生了各种不同的变化。
为了做到上面所说的事情，最简单的方法莫过于将这个值存储到被称做`变量`这样的象征性的容器中，之所以被称做变量，就是因为这个容器中的值可以随着你的需要随时变化。
在一些编程语言中，你声明的变量（容器）将会保持一个特定的值类型，比如数字或者字符串，而不能发生改变。`静态类型语言`，也被称作`强类型语言`^注^，通常这种机制能防止意外的类型转换，有利于程序的正确性。
还有些语言强调的是`类型值`而不是`变量`，这样的语言被称作`弱类型语言`或者`动态类型语言`，它们允许一个变量在任何时候保存任何类型的值。它使得程序具有很高的灵活性，允许单个变量表示一个值，这个值在可以在程序逻辑流程中的任何时刻，也无论它是什么类型。
<p class="translator">
这里关于强弱类型，静态动态语言的解释并不完全正确，实际上在严格的定义中静态类型语言和强类型语言是不一样的。具体请阅读这篇文章[弱类型、强类型、动态类型、静态类型语言的区别是什么？](https://www.zhihu.com/question/19918532) 
</p>

JavaScript是用的后一种方法，动态类型语言。意味着变量可以包含任何类型的值，而不会在保存值的时候发生强制类型转换。
正如前面提到的，我们使用var语句声明了一个变量——注意，在声明中并没有注明它的类型信息。比如下面这个简单的程序：

```javascript
var amount = 99.99;
amount = amount * 2;
console.log( amount );      // 199.98

// convert `amount` to a string, and
// add "$" on the beginning
amount = "$" + String( amount );
console.log( amount );      // "$199.98"
```

`amount`变量从数字99.99开始，之后又保存了另一个数字，即`amount * 2`的结果，199.98。
第一个console.log(..)命令为了将它打印出来，必须执行强制类型转换，把数字值转变为字符串值。
接下来的语句`amount = “$” + String(amount) `也执行了强制类型转换，把199.98转变为了字符串，并且在开始处加上了“$”符号。在这里，amount储存了这个字符串，值是“$199.98”，所以，第二个console.log(..)语句将不需要执行任何转换，直接就能将它打印出来。
JavaScript开发者们将会注意到，可以使用amount变量来同时代表99.99，199.98以及”$199.98”，这就是它的灵活性所在。而对于静态类型语言，必须要使用另一个像是smountStr这样的独立变量来保存最后一个”$199.98”，因为它们不是同一类型的值。
无论哪一种方式，你会注意到amount保存了程序运行过程中不断变化的值，这说明了变量的主要目的：管理程序的状态。
换句话说，当你的程序运行的时候，程序的变化将会在变化的值中得以体现。
变量的另一个常见的用途是`集中设定值`（centralizing value setting）。当你用一个值声明了一个变量，并且打算这个变量内部的值将不会随着程序运行而改变，这样值通常被称作常量。
通常都会在程序的顶部声明这些常量，如果你需要改变这些值，这样会方便你去寻找它们。按照惯例，JavaScript作为常量的变量，通常都是大写英文，在多个单词中用下划线_连接。
下面是个一个例子：

```javascript
var TAX_RATE = 0.08;    // 8% sales tax
var amount = 99.99;
amount = amount * 2;
amount = amount + (amount * TAX_RATE);
console.log( amount );              // 215.9784
console.log( amount.toFixed( 2 ) ); // "215.98"
```

<p class="note">
`console.log(..)`是访问了对象`console`的属性的函数`log(..)`。与之类似，`toFixed(..)`也是一个函数，它能在数字变量上访问。JavaScript并不会自动对美元进行自动格式化——因为引擎并不知道你的实际意图是什么，而且也没有货币类型。`toFixed(..)`让我们指定在第几位小数后进行四舍五入，它将会产生一个字符串。
</p>

TAX_RATE变量是唯一一个不变的常量——在这个程序中并没有能让它发生变化的代码。但是如果城市将营业税提高到9%，我们可以很容易在这里把它的值改成0.09，而不是去修改散落在程序中的0.08。
在JavaScript的最新版本中（ES6），有了一个用来声明常量的新的关键字——`const`：

```javascript
// as of ES6:
const TAX_RATE = 0.08;
var amount = 99.99;
// ..
```

常量其实就是不会变化的变量，它是非常有用的。但是常量也必须要避免在初始化之后因为某些意外而改变了其中的值。如果你想要在初始化之后，给TAX_RATE赋另外的值给它，你的程序会拒绝这个改变（在严格模式下，常量是不允许改变的，阅读第二章“严格模式”）。
顺带一提，这种针对错误的“保护”类似于静态语言的强制类型，所以你能理解为什么其他的强类型语言这么受欢迎了吧。
<p class="note">
在你的程序中，如何在变量中使用不同的值，有关这样的信息，请阅读本系列的《类型与语法》。
</p>

## 块
当你打算买新手机的时候，手机店员工必须经过一系列的步骤来完成结算。
同样的，在代码中我们经常也需要组织一些列的语句在一起，我们通常称之为一个块。在JavaScript中，块定义通常通过将一系列语句包装进一对大括号中来完成。比如：

```javascript
var amount = 99.99;// a general block
{    
  amount = amount * 2;   
  console.log( amount );  // 199.98
}
```

这种独立的块`{..}`是有效的，但是并不常见。通常情况下，块会附加到其他控制语句中，例如if语句（阅读“条件语句”），或者是loop（阅读“循环语句”），比如：

```javascript
var amount = 99.99;			// is amount big enough?
if (amount > 10) {          // <-- block attached to `if`    
  amount = amount * 2;    
  console.log( amount );  	// 199.98
}
```

我们会在下一节中解释if语句。但是就像你看到的这样，{..}块将内部的两个语句附加到了if(amount > 10)，内部语句块只会在条件成立的时候运行。
<p class="note">
与大多数语句不同，块语句不需要分号(;)来结束。
</p>

## 条件语句
“你要添加额外的屏幕保护膜吗？特价9.99元。”乐于助人的手机专卖店员工这么向你问道，等着你的决定。您可能需要先检查下自己的钱包或者是银行账户的状态来回答这个问题，但是很明显，这只是一个简单的“需要”或者“不要”的问题。
这里有些能让我们表达程序条件（即决策）的语句。
最常见的是if语句。从本质上讲，if语句就是这么一回事儿：假如这个条件为真，那么执行下列操作。比如：

```javascript
var bank_balance = 302.13;
var amount = 99.99;
if (amount < bank_balance) {   
  console.log( "I want to buy this phone!" );
}
```

If语句需要写在括号中，而且这个语句的结果必须是true或者false。在程序中，我们给出了表达式`amount < bank_balance`，它将会比较`amount`和`bank_balance`变量的值，然后计算出是true或者是false。
如果条件不成立，你也可以提供另外的选择。如果表达式的结果不是true，那么程序将会转入else子句。比如：

```javascript
const ACCESSORY_PRICE = 9.99;
var bank_balance = 302.13;
var amount = 99.99;
amount = amount * 2;

// can we afford the extra purchase?
if ( amount < bank_balance ) {    
  console.log( "I'll take the accessory!" );   
  amount = amount + ACCESSORY_PRICE;
}

// otherwise:
else {   
  console.log( "No, thanks." );
}
```

假如amount < bank_balance的结果是true，那么我们将会打印出"I'll take the accessory!"，然后给amount变量加上9.99，否则的话，else字句中我们将会回复说"No, thanks."，而且amount变量也没有改变。
正如我们在之前的“值与类型”中讨论过的一样，如果你需要的值类型和当前提供的值类型不匹配，那么就会发生强制类型转换，if语句需要布尔类型的值，假如你提供的值并不是布尔类型，那么就将会发生强制类型转换。
JavaScript定义了一系列特殊的被称做`falsy`的值，当强制类型转换发生的时候它们都将会被转换为false——它们包含了0、””（空字符串）等等。其他任何值，只要不是`falsy`的都被称作`truthy`——当强至类型转换发生的时候，它们会被转换为true。Truthy变量包含了像是99.99或者是”free”等等。更多信息阅读第二章“的Truthy & Falsy”。
条件语句并不是只有if，例如switch语句可以用来代替一系列的if..else if…语句（阅读第二章）。循环（阅读“循环语句”）语句也会使用条件语句来决定循环是否应当继续。
<p class="note">
有关条件语句的隐式变换法则的更多信息，请阅读本系列的《类型和语法》的第四章。
</p>

## 循环语句
在繁忙的时候，这里有一张需要和手机店员工讲话的顾客等候名单，只要名单上还有人，她就只能继续服务下一位顾客。
重复这样设定好的动作，直到某个确定的条件失败——换句话说，只有当条件成立的时候就会不断重复这个动作——这就是编程中循环语句的工作。循环语句有不同的格式，但是它们都满足这个基本的行为。
一个循环语句包括了测试条件以及一个块`{..}`。每一次循环执行块的过程被称之为迭代。
比如，while循环和do..while循环说明了它们将会不断重复执行块中的语句，直到某个条件的值不再是true：

```javascript
while (numOfCustomers > 0) {   
  console.log( "How may I help you?" );   
  // help the customer...    
  numOfCustomers = numOfCustomers - 1;
}
// versus:
do {   
  console.log( "How may I help you?" );    
  // help the customer...    
  numOfCustomers = numOfCustomers - 1;
} while (numOfCustomers > 0);
```

这些循环唯一实际的区别就是，条件测试是在第一次迭代之前(while)还是之后(do..while)。
在这两种形式中，如果条件为false，那么下一次迭代将不会运行。这就意味着如果条件在最开始是false，while循环将永远不会运行，而do..while循环将会运行一次。
有时候你将会预先决定好循环的计数，像是从0到9（10个数字）。你可以设定一个循环迭代的变量，比如i，让它的值从0开始，然后每一次迭代都加1。

<p class="warning">
由于各种历史原因，编程语言几乎总是从零开始的，这意味着开始并不是1，而是0^注^。如果你不熟悉这样的思维模式，那你可能需要花一些时间来适应它。
</p>

<p class="translator">
下标从0开始，其实是从C语言开始的习惯。
</p>

在每一次迭代中都会测试条件语句，所以在循环语句中其实隐含着条件语句。
在JavaScript中，我们可以使用break语句终止循环。此外，我们也能很容易的创建一个永远不会终止的循环。像这样：

```javascript
var i = 0;
// a `while..true` loop would run forever, right?
while (true) {    
  // stop the loop?   
  if ((i <= 9) === false) {
    break;    
  }  
  console.log( i );   
  i = i + 1;
}
// 0 1 2 3 4 5 6 7 8 9
```
 这一定不是你想要使用的循环形态，在这里提出它仅仅是为了说明。
虽然while(or do…while)就能够完成任务了，但是这里还有些其他的循环形式，同样能达到目的：

```javascript
for (var i = 0; i <= 9; i = i + 1) {
  console.log( i );
}
// 0 1 2 3 4 5 6 7 8 9
```

正如你所看到的，在最开始的10次迭代（i的值是从0到9）中，条件语句i<=9都是true，但是当i的值变成10的时候，条件语句的值变成了false，循环终止。
在这个循环语句中一共有三个子语句：初始化语句（i=0），测试条件子语句（i<=9），以及更新子语句。所以如果你想要用循环迭代进行计数，那么for语句是一个更加紧凑也更容易理解的形式。
还有些其他专门的循环格式，用于遍历一些特殊的值，比如对象的属性（阅读第二章），其中隐含的测试条件是所有的属性是否已经处理。“循环，直到条件失败”的理念无论在什么样子的循环中都是一样的。

## 函数
手机店的员工可能并不会用计算器计算税款以及最终的购买量。她需要定义一次这个任务，然后不断的重复。奇怪的是，该公司有一个付款登记的机器（比如电脑或者平板），这就是被称做`函数`的内置类型。
同样的，你的程序肯定也想把任务代码分解成可以重用的部件，而不是你自己一再的重复重复再重复。能做到这一点的就是定义一个函数。
函数是一段被命名的代码片段，你能够通过它的名字来调用它，每当你调用它一次，它内部的代码就会被运行一次。例如：

```javascript
function printAmount() {   
  console.log( amount.toFixed( 2 ) );
}
var amount = 99.99;
printAmount(); // "99.99"
amount = amount * 2;
printAmount(); // "199.98"
```

函数能接受参数——你传递进去的值。而且它们还能有选择性的返回一个值。

```javascript
function printAmount(amt) {   
  console.log( amt.toFixed( 2 ) );
}
function formatAmount() { 
  return "$" + amount.toFixed( 2 );
}
var amount = 99.99;
printAmount( amount * 2 );      // "199.98"
amount = formatAmount();console.log( amount );          // "$99.99"
```

函数`printAmount(..)`接受了一个名为`amt`的参数。函数`formatAmount()`返回了一个值。当然，你也可以在一个函数中结合这两种技术。
函数会被你多次调用，但是它们也能单纯作为代码的集合，即使你只打算调用一次。比如：

```javascript
const TAX_RATE = 0.08;
function calculateFinalPurchaseAmount(amt) { 
  // calculate the new amount with the tax    
  amt = amt + (amt * TAX_RATE);   
  // return the new amount  
  return amt;
}
var amount = 99.99;
amount = calculateFinalPurchaseAmount( amount );
console.log( amount.toFixed( 2 ) );     // "107.99"
```

虽然calculateFinalPurchaseAmount(..)只调用了一次，将它的行为被组织成一个单独命名的函数，这样我们使用它的逻辑(amount = calculateFinal... 语句)的时候将会更清楚。假如函数中有更多的语句，这样做的好处会更加明显。

### 作用域
如果你向手机店员工询问了一个她们店里不卖的手机型号，你肯定只能得到一个“我们店里没有这种型号”的回答。她只能访问她店里拥有的手机而已，如果你想要找到你要的手机，那么你就只能去别的手机店找了。
编程中对于这样的概念有一个专门的术语：`作用域`（技术上也称之为`词法作用域`）。在javascript中，每一个函数都有它自己的作用域。作用域基本上就是变量以及如何按照名称访问这些变量的规则的集合。只有在函数内部的代码才能访问这个函数作用域内部的变量。
变量名字在同一个作用域中是唯一的——不可能有两个不同的变量a坐在一起。但是在不同的作用域中，可以出现同样的变量名a。

```javascript
function one() {   
  // this `a` only belongs to the `one()` function  
  var a = 1;  
  console.log( a );
}
function two() { 
  // this `a` only belongs to the `two()` function  
  var a = 2;  
  console.log( a );
}
one();      // 1
two();      // 2
```

此外，作用域可以嵌套在另一个作用域中，就好像生日聚会中小丑在一个气球内部又吹了一个气球一样。如果一个作用域嵌套在了另一个作用域里面，最内层作用域内的代码可以访问访问这相互嵌套的作用域内的所有变量。
比如：

```javascript
function outer() {  
  var a = 1;  
  function inner() {   
    var b = 2;        // we can access both `a` and `b` here      
    console.log( a + b );   // 3   
  }  
  inner();    // we can only access `a` here  
  console.log( a );           // 1
}
outer();
```

此法作用域的规则中是这么说的，在一个作用域能访问到的变量不仅包括了当前作用域内的，也包括了在它外围的所有作用域^注^。
<p class="translator">
这里的外围，是指层层嵌套的外围，而不是毫无关系的外围。
</p>

所以，函数inner()能够访问到a、b两个变量，但是在函数outer()仅能访问到a——它不能访问b是因为变量b仅仅在inner()作用域内。
看看这段上面提过的代码：

```javascript
const TAX_RATE = 0.08;
function calculateFinalPurchaseAmount(amt) {  
  // calculate the new amount with the tax 
  amt = amt + (amt * TAX_RATE);  
  // return the new amount  
  return amt;
}
```

常量（变量）`TAX_RATE`可以被函数`calculateFinalPurchaseAmount()`访问，虽然我们并没有将它通过传参的方式传进去，但是因为词法作用域的关系，我们仍然可以在它内部访问这个变量。
<p class="note">
关于词法作用域的更多内容，请阅读《作用域和闭包》的前三章。
</p>

## 练习
这里绝对不能代替编程实践，大量的编写代码才是能让你成为程序员的唯一道路。
考虑到这一点，让我们试着练习一些我们在本章学习到的概念，我给出“需求”，然后你先试试看，然后参考一下我后面给出来的代码清单。
* 编写一个程序来计算你购买手机需要耗费的总价格。你会持续购买手机，直到你的银行账户中的钱都用完了。你还能为每个手机购买配件，只要每个手机的价格低于你的心里消费预期。
* 在你计算了你的进货量之后，再加上税款，然后按照正确的格式打印出申购金额。
* 最后检查你的银行账户余额，看看你能否负担得起。
* 你应该设置一些常量，“税率”、“手机价格”、“配件价格”、“消费门槛”，以及为你的“银行账户余额”设定变量。
* 你应该定义一个函数，它会计算税收然后将价格格式化，即将价格四舍五入到小数点后两位，并加上”$”符号。
* 挑战：尝试将input也整合进计划中，可以使用prompt(..)来对输入进行提示。举个例子，你可以用它来提示用户的银行账户余额。按照你的想法进行创造吧！

好了，你先去试一试吧。在你写完自己的代码之前，请不要偷看我的代码。
注意：因为这本书是介绍javascript的，所以我显然会使用JavaScript来实践，但是你可以使用任何你喜欢的语言进行了练习。
这里是我的代码：

```javascript
const SPENDING_THRESHOLD = 200;
const TAX_RATE = 0.08;
const PHONE_PRICE = 99.99;
const ACCESSORY_PRICE = 9.99;

var bank_balance = 303.91;
var amount = 0;

function calculateTax(amount) {
  return amount * TAX_RATE;
}

function formatAmount(amount) {
  return "$" + amount.toFixed( 2 );
}

// keep buying phones while you still have money
while (amount < bank_balance) {
  // buy a new phone!
  amount = amount + PHONE_PRICE;

  // can we afford the accessory?
  if (amount < SPENDING_THRESHOLD) {
    amount = amount + ACCESSORY_PRICE;
  }
}

// don't forget to pay the government, too
amount = amount + calculateTax( amount );

console.log(
  "Your purchase: " + formatAmount( amount )
);
// Your purchase: $334.76

// can you actually afford this purchase?
if (amount > bank_balance) {
  console.log(
    "You can't afford this purchase. :("
  );
}
// You can't afford this purchase. :(
```

<p class="note">
运行此JavaScript最简单的方法，就是在离你最近的浏览器的开发者控制台中输入它。
你是怎么做的？你已经看到了我的代码，尝试改变一下里面的常数，然后看看程序在不同的值中是如何运行的。
</p>

## 综述
学习编程并不是一个复杂而压倒一切的过程，其实只有寥寥数个基本概念围绕着你。
这就像是搭积木，要建立高塔，你首先需要放好那些最为基础的积木块。对于编程而言，这里有一些对于编程而言最为基础的基础方块：
* 你需要运算符去执行对变量的操作
* 你需要值与类型来执行不同数据类型的操作，像是number的数学计算，string的输出。
* 在程序执行过程中，你需要变量来储存数据
* 你需要条件语句来做选择
* 你需要循环来重复执行任务，直到条件不成立
* 你需要函数来组织你的代码，让它成为单独的逻辑和可重用的功能块。

代码注释编写可读性好的代码的有效方法，如果程序发现了问题，使得程序易于理解、维护和修复。
最后，请不要忽视实践的力量。学习写代码最好的方式就是写代码。
我很高兴你也在学习如何编写代码，保持下去！不要忘记了参考一些其他的初学编程的资源（书籍、博客、在线培训等）。这一章以及这本书是一个伟大的开始，但也仅仅个简短的介绍。
下一章将会从JavaScript的特定角度来复习这一章的很多概念，这些概念大部分也是本系列书籍之后将会更加深入探讨的主要主题。


# 第二章：所谓JavaScript
在上一个章节中，我介绍了对于编程而言的基础结构，像是变量、循环、条件以及函数。当然，这些代码都是用JavaScript编写的。但是在这个章节中，为了能让你成为一名真正的JS开发人员，我将会关注那些你需要特别注意的关于JavaScript的概念。
我们并不会深入讲解本章中将要介绍的概念，它们会在本系列书籍的后续中详细阐述。你可以认为本章是作为整个系列其他书籍的概述。
如果你是个JavaScript的新手，你应该多花点时间来复习这里的概念和代码。不要指望你立刻就能完全理解这些概念，任何良好的基础都是一砖一瓦认真垒起来的。
深入学习JavaScript的旅程，将会从这里开始。

<p class="note">
就像我在第一章说的那样，你一定要自己试试在这一章里你看到的所有代码。另外，有些代码只能在使用最新的JavaScript解释器的引擎中才能运行（通常被称为“ES6”，它是ECMScript的第六版，ECMScript是JS规范的正式名称），如果你碰巧使用的是旧的、ES6之前的浏览器，那么代码可能无法正常工作，建议你使用现代浏览器（比如Chrome、Firefox或者IE^注^）。
</p>

<p class="translator">
实际上IE对于ES6的支持非常少，微软也已经基本放弃了它。在我翻译这篇文章的现在，微软主推的浏览器是edge，对ES6的支持非常棒。
</p>

## 值与类型
  正如我在第一章提到的，JavaScript拥有的是`类型化的值`，而不是`类型化的变量`。下面是它内建的类型们：
* `String`
* `Number`
* `Boolean`、`null`和`undefined`
* `Object`
* `Symbol`（ES6中新加入的）

JavaScript提供了`typeof`运算符来检查值的类型：

```javascript
var a;
typeof a;               // "undefined"

a = "hello world";
typeof a;               // "string"

a = 42;
typeof a;               // "number"

a = true;
typeof a;               // "boolean"

a = null;
typeof a;               // "object"

a = undefined;
typeof a;               // "undefined"

a = { b: "c" };
typeof a;               // "object"
```

typeof运算符将会返回一个字符串，而这个字符串总是那六种类型（ES6中，将会有7种）。必须要注意的是，`typeof  “abc”`，将会返回`"string"`，而不是`string`。
注意这里，在这个代码片段中，a这个变量保存了各种不同类型的值，呈现出了多种不同的形式。typeof a不是用来查询变量a的类型，而是用来查询a这个变量中临时保存的值的类型。所以我们才说，在JavaScript中只有值具有类型，变量只是那些值的简单容器而已。
`typeof null`是个有趣的例子，你可能以为它会返回"null"，但实际上它却返回了"Object"。
<p class="warning">
这是js中一个存在已久的bug，不过它可能永远不会被修复了。因为已经有太多的网站代码依赖这个bug了，修复它可能会造成更多的问题。 
另外，请注意`a = undefined`，我们明确的设置a的值为“undefined”，但它表现得跟一个还没被赋值的变量是一样的，比如在刚才的代码片段的顶端用了var a。变量赋值为undefined有很多种方法，其中包括了不返回值的函数以及使用`void`运算符。
</p>

### 对象
对象（object）指的是一种复合值，你可以设置它的属性（命名位置），每个属性都有它们自己的任何类型的值。这可能是在JavaScript中最有用的类型之一。

```javascript
var obj = {
  a: "hello world",    
  b: 42,
  c: true
};

obj.a;      // "hello world"
obj.b;      // 42
obj.c;      // true
obj["a"];   // "hello world"
obj["b"];   // 42
obj["c"];   // true
```

用可视化的方式来看obj的值更直观点：
![可视化的对象](/img/up-going/04.png)
属性可以通过点标记（比如`obj.a`）和方括号标记(比如`obj[‘a’]`)访问，点标记更短小精悍而且通常而言更容易阅读，因此一般情况下会倾向于使用点标记。
方括号标记在你将要访问的属性名中包含特殊符号的情况下比较有用，比如`obj[‘hello world!’]`——当通过方括号访问时，这些属性还被称作键（`keys`）。方括号标记需要一个变量（一会儿再解释）或者是string字面量（写在引号中）。
当然，如果你想访问的一个属性/键，而它的名字在其他变量中已经存储占用了，这个时候方括号标记也是很有用的，比如：

```javascript
var obj = {  
  a: "hello world",   
  b: 42
};

var b = "a";
obj[b];         // "hello world"
obj["b"];       // 42
```

<p class="note">
有关JavaScript对象的更多信息，请参考系列书籍中的《this和对象原型》第三章。
</p>

还有一些其他的值类型你会在JavaScript中经常用到：数组和函数。但是，与其说它们是独特的内置类型，其实它们是Object类型的子类型——Object类型的专用版本。

#### 数组
数组也是一个可以保存任何值的对象，但是它不是用属性/键命名，而是用数字来索引下属的属性值的。例如：

```javascript
var arr = [   
  "hello world", 
  42,  
  true
];

arr[0];         // "hello world"
arr[1];         // 42
arr[2];         // true
arr.length;     // 3

typeof arr;     // "object"
```

<p class="note">
数组的索引是以0开始计数的。
</p>

可视化的方式来看看数组的结构：
![可视化的数组](/img/up-going/05.png)
因为数组是特殊的对象（正如typeof运算符的结果），它也有属性，其中包括了自动更新长度的属性。
理论上来说，你可以将数组作为一个普通的对象使用，比如自己随意命名属性名，或者你可以在使用对象的时候只给数字作为属性名来模拟数组。然而这种做法通常会被认为是对不同类型的不当使用，一般不推荐。
最好的最自然的方法当然是使用数组来进行数字索引，使用对象来应对命名属性的情况。

#### 函数
另一个对象的子类型是你会在所有JS程序中都会用到的——函数：

```javascript
function foo() { 
  return 42;
}

foo.bar = "hello world";

typeof foo;         // "function"
typeof foo();       // "number"
typeof foo.bar;     // "string"
```

再强调一遍，函数是对象的子类型——typeof返回的是“function”，也就是说函数是一种主要类型，也因此具有属性，不过你基本只会在非常有限的情况下使用对象属性（比如foo.bar）。
<p class="note">
想要了解更多的关于JS值和类型的信息，请阅读本系列书籍的《类型和语法》的前两章。
</p>

### 内置类型方法
我们之前讨论的内置类型和子类型拥有着一些相当强大有用的属性和方法，比如：

```javascript
var a = "hello world";
var b = 3.14159;

a.length;               // 11
a.toUpperCase();        // "HELLO WORLD"
b.toFixed(4);           // "3.1416"
```

变量a是如何调用`a.toUpperCase()`方法的，这比起在值中已经存在的方法而言要复杂得多。简单的来说，`String`（大写S）对象的封装被称作“原生”，它是原始的string类型，在这个对象的原型（prototype）之中定义了`toUpperCase()`方法。
当你把`"Hello world"`这样的原始值当作是对象的时候，引用它的属性或调用它的方法（就像在上面的代码片段中的`a.toUpperCase()`一样），JS将会自动把“盒子”里的值连接到对象的原始包装中（这个过程是被隐藏了起来的）。
字符串可以通过`String`对象封装起来，同样的，数字也可以通过`Number`对象封装起来，布尔值也可以被`Boolean`对象封装。在大多数情况下你并不需要担心什么，可以直接使用这些对象封装形式下的值——prefer the primitive value forms in practically all cases and JavaScript will take care of the rest for you.
<p class="note">
关于原生JS和封装，请阅读《类型和语法》的第三章。想要更多的了解对象原型，请参考《this和对象原型》一书。
</p>

### 比较值
在JS程序中，有两种主要的值类型比较，相等和不相等。无论什么样的值，无论什么样的类型，任何比较运算的结果都是严格的布尔型值（`true`或者`false`）。

#### 强制类型转换
在第一章里我们谈论过这个话题了，现在我们复习一下。
强制类型转换在JS中有两种形式，显式和隐式。显式的类型转换就是我们能从代码中非常明显的直接看到值将要发生的从一种类型转换到另一种类型的情况。而隐式强制类型转换更多的是运算符引发的副作用。
你可能经常听到“强制类型转换是恶魔”这类带有强烈情绪的感想，毕竟强制类型转换会带来很多令人感到惊讶的结果。对于开发者而言，也许它带来的挫折比起语言本身带来的惊喜都还要多。
强制类型转换并不是恶魔，这其实并不奇怪。事实上，在多数情况下你能够构造出合理且易于理解的类型转换，甚至于可以极大的提高程序的可读性。但是，现在我们并不会在这里花费太多时间——《类型与语法》的第四章涵盖了几乎所有的方面。

这里是个显式类型转换的例子：

```javascript
var a = "42";
var b = Number( a );

a;              // "42"
b;              // 42 -- the number!
```

还有，这里是个隐式类型转换的例子：

```javascript
var a = "42";
var b = a * 1;  // "42" implicitly coerced to 42 here

a;              // "42"
b;              // 42 -- the number!
```

#### Truthy & Falsy

在第一章，我们简要的提及了`truthy`和`falsy`这两类值的性质：当一个非布尔值转换到布尔值的时候，它会变成`true`还是`false`？
在JavaScript中，`falsy`值的清单如下：
* `""`（空字符串）
* `0`，`-0`，`NaN`（非法数字）
* `null`，`undefined`
* `false`

其余的值就都是`truthy`了，下面是一些例子：
* `"hello"`
* `42`
* `true`
* `[ ]`，`[ 1, "2", 3 ]`（数组）
* `{ }`，`{ a: 42 }`（对象）
* `function foo() { .. }`（函数）

当非布尔值转换为布尔值时候，它只会遵循上述`truthy`和`falsy`的规则，记住这些规则非常重要。当然了，这些规则并不是故意迷惑你让你弄混淆的，实际上它非常好记忆，你只需要记住哪些是`Falsy`的就行了，其余的全是`truthy`。

#### 相等
相等运算符有四个：`==`，`===`，`!=`，`!==`。使用`!`这样的形式化符号构成了和相等运算符相对应的“不相等”版本。但是，必须要注意的是，不要把`不相等`和`不等式`弄混淆^注^了。
<p class="translator">
不相等，原文`non-equality`，这里是指`!=`和`!==`运算符。
不等式，原文`inequality`，这里是指`<`、`>`、`<=`以及`>=`运算符
</p>

`==`和`===`它们的区别在于，`==`只会检查值，而`===`将会检查值和类型。这样的描述不太准确，它们真正的特点应该是这样的，`==`在比较值的时候允许对值进行类型转换，而`===`是不允许的。这也是`===`被称做`严格相等`的原因。
下面是允许隐式类型转换的`==`和不允许类型转换的`===`之间的比较：

```javascript
var a = "42";
var b = 42;

a == b;         // true
a === b;        // false
```

在`a == b`的比较中，JS意识到了这两个变量内部值的类型并不匹配，所以它按照一系列的步骤将这两个值都进行了强制类型转换，直到它们的类型匹配了，此时它们才能进行简单值的相等检查。
现在请你想想，这里有两种方式能让`a == b`成立，要么最终是`42 == 42`，要么最终是`"42" == "42"`，是哪一个呢？
答案是：`"42"`会被转换成`42`，最终变成`42 == 42`。在这个简单的例子中，似乎无论采用哪种方式，最终的结构都是一样的，但是有非常多比这复杂的多的情况。所以重点不是结果是什么，重点是你是如何到达那里的。
`a === b`结果是`false`，因为它不允许强制类型转换，所以它们的比较显然是失败的。很多开发者认为，`===`的结果预测起来要更为容易，所以他们总是使用`===`，而远离`==`。我认为这样的行为是非常短视的，我相信假如你能够花上一点时间来学习`==`的原理，它将会是个非常有用的工具。
我不打算在这里仔细讲解`==`运算符强制类型转换的所有细节，虽然它在大部分情况下都是非常合理的，但是在一些特殊的场合中你需要多加小心。你可以阅读[ES5规范](http://www.ecma-international.org/ecma-262/5.1/)的第11.9.3节，了解一下它确切的规则，相比于它的负面作用，你一定会惊讶于这种机制是多么的简单。
将它的大量细节总结为几个简单的知识点，这将会帮助你判断在各种情况下是使用`==`还是`===`：
* 如果任一值可能是`true`或者是`false`，不要用`==`。
* 如果任一值可能是这些特定的值（`0`、`""`或者`[]`——空数组），不要使用`==`。
* 如果是其他情况，你可以放心的使用`==`。它不仅是安全的，但是在许多情况下将会大大简化你的代码。

这些规则需要你仔细思考你的代码，两个变量的值的类型可以通过什么样的变化来进行比较。如果你可以确定这一点，那么`==`是安全的，尽情使用它吧！如果你不能确定，那么就使用`===`，就是这么简单。
`!=`不等于运算符和`==`是成对的，`!==`和`===`也是一对。所有的规则和意见和我们刚才讨论的都相对应。
如果你比较两个非原始值，比如对象（包括函数和数组），你应该特别注意`==`和`===`的规则，因为这些值实际上都是引用，所以`==`和`===`都将会简单判断它们的引用是否匹配，而不会比较它们的内部的属性值。
比如，在默认情况下，数组的强制类型转换会把它自己转换成字符串，而这个字符串是数组所有属性值以及在它们之间加上逗号(`,`)的产物。你可能会认为具有相同内容的数组相等，但是它们不是：

```javascript
var a = [1,2,3];
var b = [1,2,3];
var c = "1,2,3";

a == c;     // true
b == c;     // true
a == b;     // false
```

<p class="note">
想要了解关于`==`判断的规则，请阅读ES5规范（11.9.9节），或者是本系列书籍的《类型和语法》第四章。如果想了解值与引用的更多信息，请阅读刚才提到的那本书的第二章。
</p>

#### 不等

`>`、`<`、`>=`以及`<=`运算符通常被用于不等于运算，即所谓`关系比较`。典型的，它们常常被用于数字之间的大小比较。它们很容易理解，像是`3 < 4`。
但是在JavaScript中，字符串值也可以使用这几个运算符进行比较，它们将会按照典型的字母顺序进行比较。（`"bar" < "foo"`）。
强制类型转换呢？规则和`==`相类似（并不完全一样），值得注意的是，没有和`===`类似的所谓“严格不相等”运算符。
比如：

```javascript
var a = 41;
var b = "42";
var c = "43";
　
a < b;      // true
b < c;      // true
```

这里发生了什么？请阅读ES5规范的第11.8.5节，它将会告诉你当`<`运算符两边都是字符串的时候（比如`b < c`），它将会按照字典顺序（就是按照字典上的字母排序）进行比较。但是，当其中一个或者全都不是字符串的时候（比如`a < b`），它将会把两个值都转换到数字，然后按照数字的规则进行比较。
当你对不同类型的值进行比较的时候，你可能会遇到的最大的问题——记住，这里没有所谓“严格不相等”运算符——某个值不能转换成有效数字，比如：

```javascript
var a = 42;
var b = "foo";
　
a < b;      // false
a > b;      // false
a == b;     // false
```

等等，为什么这三个比较都抛出了`false`？因为变量`b`的值被转换成了`非法数字NaN`了。在不等运算符中，规范中提出，`NaN`对于其他数字而言即不大于也不小于。
这里我想提一下`==`匹配失败的另一个原因，那就是`a == b`可能会被解释成`42 == NaN`或者`"42" == "foo"`——正如刚才我们所说的那样，将会是前者。

<p class="note">
有关不等于运算符的更多信息，请参考ES5规范第11.8.5节，也可以阅读《类型和语法》的第四章。
</p>

## 变量

在JavaScript中，变量名字（包括函数名字）必须是合法的`标识符`，当你想用非传统的字符（比如Unicode）命名，这种情况下标识符的有效字符的规则比较严格且复杂。如果只考虑典型的ASCII字母数字字符，这样的规则比较简单。
标识符的起始字符必须是`a`-`z`，`A`-`Z`，`$`或者`_`。然后它可以包含以上所有字符再加上数字`0`-`9`。
一般来说，对于作为变量标识符的属性名称也适用同样的规则。然而，某些特殊的字词不能用作变量，但是可以用作属性名。这些字词被称做`保留字`，还有JS的关键字们（`for`、`in`、`if`，等等）以及`null`，`true`，`false`。
<p class="note">
关于保留字的更多信息，请参考《类型和语法》的附录A。
</p>

### 函数作用域
你使用了`var`关键字来声明了一个变量，这个变量将会属于当前的函数作用域；如果你是在所有函数的外部进行声明，那么这个变量将会处于全局作用域。
#### 声明提升
无论`var`出现在哪个作用域内部，声明的变量将会在当前作用域的全部范围内起作用。
这种行为被称作`声明提升`，它的意思是说，当某个变量使用`var`声明的时候，这个变量的声明将会被“搬运”到当前作用域的顶部。从技术上来说，这是解释器对代码进行预编译的过程中完成的，但是现在我们可以先跳过这些细节。
看下述的代码：

```javascript
var a = 2;

foo();                // works because `foo()`
                      // declaration is "hoisted"

function foo() {
  a = 3;
  console.log( a );   // 3
  var a;              // declaration is "hoisted"
                      // to the top of `foo()`
}

console.log( a );     // 2
```

<p class="warning">
在作用域中依靠声明提升，在变量声明之前使用这个变量，这并不是一个好主意，因为这将会让你的代码逻辑变得更加混乱。不过在函数声明之前调用函数，这种方式倒是更为常见。
</p>

#### 作用域嵌套

当你声明了一个变量，它在当前作用域的任何地方都是有效的，而且，在它内部嵌套的作用域内也是有效的，例如：

```javascript
function foo() {
    var a = 1;
    function bar() {
        var b = 2;
        function baz() {
            var c = 3;
            console.log( a, b, c ); // 1 2 3
        }
        baz();
        console.log( a, b );        // 1 2
    }
    bar();
    console.log( a );               // 1
}

foo();
```

请注意，变量`c`在`baz()`内部是有效的，因为它就是在这个函数内部声明的。基于相同的理由，变量`b`在`foo()`函数中是无效的。
假如说你在作用域中尝试访问某个无效变量的值，你将会得到一个`ReferenceError`错误。如果你尝试设置一个还没有被声明的变量，那么你将会创造一个全局作用域的变量（坏了！），如果你是在`严格模式`下这么做，你将会得到一个错误（参考“严格模式”）。让我们来看看：

```javascript
function foo() {
    a = 1;  // `a` not formally declared
}

foo();
a;          // 1 -- oops, auto global variable :(
```

这是一个非常糟糕的做法，不要这样做！在使用变量前一定要声明你的变量。
在ES6之前，我们只有函数作用域，就是说我们声明的变量会在整个函数范围内有效，而ES6给我们带来了`let`关键字，它能让你在块(`{..}`)级范围内声明变量。除了一些细节上的差异，作用域的规则和行为大致上相同，我们现在来看看下面这个函数：

```javascript
function foo() {
    var a = 1;

    if (a >= 1) {
        let b = 2;

        while (b < 5) {
            let c = b * 2;
            b++;

            console.log( a + c );
        }
    }
}

foo();
// 5 7 9
```

这里因为使用`let`代替了`var`，变量`b`将会仅属于`if语句`而不是整个foo()函数。相似的，变量`c`将会仅属于`while循环`中。块级作用域将能够更加细致的管理你的变量，能够让你的代码更容易维护。
<p class="note">
有关作用域的更多信息，请参考《作用域和闭包》；有关块级作用域的更多信息，请参考《ES6和超越》。
</p>

## 条件语句

在第一章中，我们简明扼要的介绍了`if`语句，JavaScript提供了几种其他的机制，我们一起来看看。
有时候你会发现，你需要写一系列的`if..else..if`语句，就像这样：

```javascript
if (a == 2) {
    // do something
}
else if (a == 10) {
    // do another thing
}
else if (a == 42) {
    // do yet another thing
}
else {
    // fallback to here
}
```

这种结构当然是能够正常工作的，但是显得有点冗长了，因为程序运行的时候会对每一个指定条件进行测试。面对这种情况，这里有另外一种选择，`switch`语句：

```javascript
switch (a) {
    case 2:
        // do something
        break;
    case 10:
        // do another thing
        break;
    case 42:
        // do yet another thing
        break;
    default:
        // fallback to here
}
```

假如你只想运行在某一个`case`下的语句，那么`break`语句是必不可少的。如果你在某个`case`中省略了`break`语句，无论下一个`case`是否匹配，程序都将会继续运行下一个`case`中的语句。这种行为被称做`fall through`，它在某些情况下是非常有用/所需的：

```javascript
switch (a) {
    case 2:
    case 10:
        // some cool stuff
        break;
    case 42:
        // other stuff
        break;
    default:
        // fallback
}
```

在这里，假如`a`等于`2`或者`10`，程序都将会运行"some cool stuff"部分代码。

在JavaScript中，条件语句还有另外一种形式，它被称做`条件运算符`，它是`三元运算符`的一种，它就像是`if..else`语句更加简洁的形式，像这样：

```javascript
var a = 42;

var b = (a > 41) ? "hello" : "world";

// similar to:

// if (a > 41) {
//    b = "hello";
// }
// else {
//    b = "world";
// }
```

假如这个测试表达式`a > 41`的结果为`true`，那么表达式的结果就等于第一条`"hello"`，否则就等于第二条`"world"`，然后无论表达式结果是什么，都会把结果赋值给变量`b`。
条件运算符不一定必须运用在赋值语句中，但这绝对是最常见的用法。
<p class="note">
关于条件测试以及`switch`和`? :`运算模式的更多信息，请参考《类型和语法》。
</p>

## 严格模式

ES5为语言增加了“严格模式”，顾名思义，在这个模式下很多语言规则、行为、语法都被收紧了。通常来说，这些限制能够让代码更加安全更加合适。此外，在严格模式下，你的代码将会更好地被解释器优化。严格模式拥有着诸多的优点，所以你应该在你所有的程序中使用它。
你可以选择把严格模式运用在某个独立的函数里，亦或者是整个文件，这取决于你把`"use strict"`放在那里：

```javascript
function foo() {
    "use strict";

    // this code is strict mode

    function bar() {
        // this code is strict mode
    }
}

// this code is not strict mode
```

对比这个：

```javascript
"use strict";

function foo() {
    // this code is strict mode

    function bar() {
        // this code is strict mode
    }
}

// this code is strict mode
```

严格模式和非严格模式有一个非常关键的不同（改进！），那就是严格模式不允许通过省略`var`来进行隐式的全局变量声明。

```javascript
function foo() {
    "use strict";   // turn on strict mode
    a = 1;          // `var` missing, ReferenceError
}

foo();
```

当你打开严格模式的时候，突然间被抛出的一堆错误给砸晕了，代码的运行也变的奇怪了起来，你可能会感到惊慌，不想再使用严格模式。但是，那样的想法绝不是个好主意，因为如果你的程序在严格模式下出现了问题，几乎可以肯定这表明了你应该马上去修复你的程序！
严格模式不仅会让你的代码更加安全，让你的代码被优化的更好，这也代表了语言在未来的发展方向。现在你还能比较容易的开始使用严格模式，要是你一直拖着不使用，以后会更加难以习惯。

<p class="note">
关于严格模式的更多信息，请参考《类型和语法》第5章。
</p>

## 作为值的函数

到目前为止，我们已经讨论了函数作用域在JavaScript中的主要机制，你应该还记得典型的函数声明的语法：

```javascript
function foo() {
    // ..
}
```

虽然这似乎不是那么明显，但是，我必须指出的是，`foo`基本上只是在声明这个函数的外部封闭作用域中的一个`变量`。函数本身就是一个值，就和`42`或者是`[1,2,3]`一样的值。
这初次听起来似乎有点不可思议，所以请稍微花点时间来仔细思考一下。你不仅能传输值（形参）到函数中，而且函数本身也能作为一个值并把它赋值给变量，它还能传递值又或者是从其他函数返回值。
因此，就像其他任何值和表达式那样，函数值也可以被认为是个表达式。
像这样：

```javascript
var foo = function() {
    // ..
};

var x = function bar(){
    // ..
};
```

第一个函数表达式被赋值给了`foo`变量，不过这个函数没有任何名字，所以是匿名函数。
第二个函数表达式的名字的名字是`bar`，也将它赋值给了变量`x`。尽管匿名函数表达式也是几位常见的，但通常还是优先考虑具名函数表达式。

<p class="note">
更多的信息，请参考《作用域和闭包》。
</p>

### 立即执行函数表达式(IIFEs)

在上面的代码片段中，两个函数表达式都没有被执行——当然，假如我们在代码中写下`foo()`以及`x()`，它们就运行了。
这里还有另外一种方式来运行函数表达式，这种方式通常被称作`立即执行函数表达式(IIFEs)`。

```javascript
(function IIFE(){
    console.log( "Hello!" );
})();
// "Hello!"
```

包裹着函数表达式`(function IIFE(){ .. })`外围的`(..)`，在这里是JS的语法需要，以防止它被解释器识别为正常的函数声明。
在表达式最后的`()`，就是它切实执行了在它之前紧跟着的函数表达式。
这听起来好像有点奇怪，但这和你第一次瞥见外国人的情况有点相似。参考下面的代码，思考一下`foo`和`IIFE`之间的相似性：

```javascript
function foo() { .. }

// `foo` function reference expression,
// then `()` executes it
foo();

// `IIFE` function expression,
// then `()` executes it
(function IIFE(){ .. })();
```

正如你所看到的那样，在执行符号`()`之前的部分`(function IIFE(){ .. })`，从本质上来讲和在执行符号`()`之前的`foo`是一样的。在这两种情况中，函数的引用都是通过`()`来执行的。
因为IIFE是个函数，函数就会创建变量作用域，所以使用IIFE通常是为了避免声明的变量影响IIFE之外的代码：

```javascript
var a = 42;

(function IIFE(){
    var a = 10;
    console.log( a );   // 10
})();

console.log( a );       // 42
```

IIFEs也能够返回值：

```javascript
var x = (function IIFE(){
    return 42;
})();

x;  // 42
```

`42`就是从`IIFE`中`return`的。其中，`IIFE`这个具名函数被执行了，然后把它返回的值赋值给了`x`。

### 闭包

闭包，这是JavaScript中最重要也是最难理解的概念之一。这个概念将会在《作用域和闭包》中详细讲解，在这里我想简单提几件事情，好让你对这个概念有一个感性的认识，这将会成为是你的JS技能中最重要的技术之一。
函数运行结束之后，你仍然能通过某种方式去访问这个函数作用域内的变量。这就是“闭包”。
比如：

```javascript
function makeAdder(x) {
    // parameter `x` is an inner variable

    // inner function `add()` uses `x`, so
    // it has a "closure" over it
    function add(y) {
        return y + x;
    };

    return add;
}
```

每次调用外部的`makeAdder(..)`函数时，它都会返回内部函数`add(..)`的引用，而由于内部函数使用了变量`x`，所以即便外部`makeAdder(..)`函数已经运行完毕了，无论传递了什么样的`x`的值进去，它们都被保存起来了。现在，我们来运行`makeAdder(..)`：

```javascript
// `plusOne` gets a reference to the inner `add(..)`
// function with closure over the `x` parameter of
// the outer `makeAdder(..)`
var plusOne = makeAdder( 1 );

// `plusTen` gets a reference to the inner `add(..)`
// function with closure over the `x` parameter of
// the outer `makeAdder(..)`
var plusTen = makeAdder( 10 );

plusOne( 3 );       // 4  <-- 1 + 3
plusOne( 41 );      // 42 <-- 1 + 41

plusTen( 13 );      // 23 <-- 10 + 13
```

简单说说这些代码是如何工作的：
1. 当我们调用`makeAdder(1)`的时候，我们得到了内部`add(..)`的引用，它保存了变量`x`的值`1`。然后我们把这个函数的引用赋值给了变量`plusOne`。

2. 当我们调用`makeAdder(10)`的时候，同样的，我们又得到了内部`add(..)`的引用，它保存了变量`x`的值，当然此时是`10`。然后我们把这个函数的引用又赋值给了变量`plusTen`。

3. 当我们调用`plusOne(3)`的时候，它将`3`（它内部的`y`）和`1`（被保存下来的`x`）相加，然后我们得到了`4`。

4. 当我们调用`plusTen(13)`的时候，它将`13`（它内部的`y`）和`10`（被保存下来的`x`）相加，然后我们得到了`23`。


这看起来好像很奇怪，也让人感到困惑——没关系的！只要大量练习，就能理解它。
请相信我，一旦你理解了它，它将是非常强大和有用的技术。 “闭包”绝对值得让你的大脑烧上那么一会儿。在接下来的章节，我们将会做些关于闭包的练习。

#### 模块

闭包在JavaScript中最常见的用法就是模块模式。从外部来看隐藏了内部的实现细节（变量、函数），从外部只能访问公共的API，这种形式的代码集合就被称为`模块`。
比如：

```javascript
function User(){
    var username, password;

    function doLogin(user,pw) {
        username = user;
        password = pw;

        // do the rest of the login work
    }

    var publicAPI = {
        login: doLogin
    };

    return publicAPI;
}

// create a `User` module instance
var fred = User();

fred.login( "fred", "12Battery34!" );
```

`User()`函数在作用域内保存着变量`username`和`password`，以及内部的`doLogin()`函数。这些都是无法从外部访问到的`User模块`的内部细节。
<p class="warning">
我们在这里并不会调用`new User()`，尽管这对大多数读者来说更为常见。在这里`User()`仅仅只是个函数，而不是能够被实例化的`类`，所以它也就只能进行普通的调用。在这里使用`new不太合适，甚至有点浪费。
</p>

执行了`User()`就创建了User模块的一个实例——创建了一个全新的作用域。而且，这个副本保存了在它其中的每一个变量/函数。我们将它赋值给了变量`fred`，如果我们再次运行`User()`，我们将会得到另一个新的，不同于`fred`的实例。
内部的`doLogin()`函数因为闭包的关系保存着`username`和`password`，这意味着即便是在`User()`运行结束之后，也能够访问刚才的两个变量。
`publicAPI`是个包含着`login`属性的对象，而这个`login`属性又引用了内部的`doLogin()`函数。当我们从`User()`返回了`publicAPI`的时候，它就成为了我们称之为`fred`的实例。
通常情况下，在外部的`User()`函数执行完成之后，你会觉得像是`username`和`password`这样的内部变量已经小时，但在这里他们没有，因为`login()`函数的存在，这个闭包让它们保持着存活。 
这就是为什么当我们调用`fred.login()`——等效于调用内部函数`doLogin()`——的时候，我们仍然能访问到`username`和`password`这样的内部变量。
虽然这只是对闭包和模块的简单一瞥，甚至于你还感到有些混乱，但这仍然是个好机会，你的大脑要习惯这个概念还需要点时间和实践。

从这里出发，去阅读《作用域和闭包》吧，那里将会对这个概念做更加深入的探索。

## `this`标识符

在JavaScript中，`this`标识符是另一个非常容易被弄错的概念。关于这个概念，在《this和对象原型》中有非常详尽的讲解，在这里我只是简单介绍一下。
虽然看上去`this`和`面向对象编程`有些关系，但是在JavaScript中，`this`的机制却又有所不同。
假如某个函数内部有一个`this`引用，这个`this`的引用通常都是一个对象，但是这个被引用的对象具体是哪一个，这就要看这个函数是如何被调用的了。
`this`绝不是指函数本身，这是最为常见的误解，一定要牢记这一点。
这是个快速的例证：

```javascript
function foo() {
    console.log( this.bar );
}

var bar = "global";

var obj1 = {
    bar: "obj1",
    foo: foo
};

var obj2 = {
    bar: "obj2"
};

// --------

foo();              // "global"
obj1.foo();         // "obj1"
foo.call( obj2 );   // "obj2"
new foo();          // undefined
```

关于`this`的设置，这里有四条规则。它们已经在上面代码片段的最后四行中展示了出来：

1. 在非严格模式下，`foo()`最终将`this`设定成了全局对象——在严格模式下，`this`将会是`undefined`，而且你还会在访问`bar`属性的时候得到一个错误——所以`"global"`就是`this.bar`的值。

2. `obj1.foo()`将`this`设定为了`obj1`。

3. `foo.call(obj2)`将`this`设定为了`obj2`。

4. `new foo()`将`this`设定为了一个新的空对象。

底限：要真正明白`this`到底指向了什么，你必须检查函数是如何被调用的，它总归就是这上面四种方法中的一种，然后你就能明白`this`指向的到底是什么了。
<p class="note">
有关`this`的更多信息，请参考《this和对象原型》第一、二章。
</p>

## 原型

JavaScript的`原型`机制是非常复杂的。同样的，我在这里也只会简单介绍一下，如果你想要了解这个机制的相关细节，请阅读《this和对象原型》的第4-6章。
当你引用某个对象的属性的时候，如果被引用的属性并不存在，JavaScript将会自动在对象内部的原型引用对象中寻找你需要的属性。如果缺少某种属性，你可以把这想象成一种备用。
在创建对象的时候，该对象的内部原型引用就已经完成了对另一个对象的引用了。有一个内置方法能简单的说明这件事情，这个方法叫做`Object.create(..)`：

```javascript
var foo = {
    a: 42
};

// create `bar` and link it to `foo`
var bar = Object.create( foo );

bar.b = "hello world";

bar.b;      // "hello world"
bar.a;      // 42 <-- delegated to `foo`
```

用可视化的方式来说明`foo`和`bar`之间的关系：

![对象原型连接](/img/up-going/06.png)

属性`a`确实不存在于对象`bar`中，但是因为`bar`的原型连接到了对象`foo`，JavaScript自动回退到了`foo`中，寻找属性`a`。
这种连接看起来似乎是有点奇怪的特性，这种特性最常见的运用方式就是试图模仿/假扮`类`的`继承`机制——虽然我个人认为这是在滥用这个特性。
应用原型还有一种更为自然的模式，被称做“行为委托”。简单的来说就是在这里你有意设计了个你要链接的对象，使它能够代理你需要的部分行为。
<p class="note">
有关原型和行为委托的更多信息，请参考《this和对象原型》的第4-6章。
</p>

## Old & New

我们已经讲解了很多关于JS的特性了，在本系列书籍余下的部分中也包含了JS的绝大部分特性，但是即便如此，仍然有很多新添加的特性我们没有覆盖到，这些特性在一些老的浏览器中并不支持。事实上很多在规范里最新的特性，到现在为止都还没有浏览器实现。
所以，你对于这些新东西是怎么想的吗？先等个几年，等着浏览器实现了这么多新东西再说吗？
这确实是很多人面对现状的态度，但这确实不是一个正确的对待JS的态度。
这里有两个主要的技术，你能利用这两种技术在旧版本的浏览器中使用JavaScript的最新特性。

### Polyfilling^注^

<p class="translator">
这个单词我实在是找不到合适的词语翻译，大家先将就一下……反正就是这么个意思……
</p>

这个单词"polyfill"(Remy Sharp)([what is a polyfill?](https://remysharp.com/2010/10/08/what-is-a-polyfill))是指，能在旧的JS环境中运行，并且和最新的JS特性产生同样行为的代码片段。
比如，ES6中弃用了原来的`isNaN(..)`方法，重新定义了被称做`Number.isNaN(..)`的方法， 它用于检测输入的数字是否是`NaN`这个值。这个特性很容易polyfill，无论用户是否处于ES6浏览器中，你都能在代码中使用它。
比如，添加如下代码：

```javascript
if (!Number.isNaN) {
    Number.isNaN = function isNaN(x) {
        return x !== x;
    };
}
```

当这个方法已经存在的时候，比如用户已经在使用ES6的浏览器了，这里的`if`语句会防止我们将它重新定义。假如这个方法还不存在，那么我们将会自己定义`Number.isNaN(..)`。
<p class="note">
在这里我们利用了“怪癖”来检查`NaN`值——在整个JS语言中，`NaN`是为唯一一个不等于自身的值。所以，当`x != x`结果是`true`的时候，这个值就一定是`NaN`。
</p>

并不是所有的新特性都能被polyfill的，有时候大部分行为都能被polyfill，但是却存在一些小偏差，你必须非常非常小心的去实现自己的polyfill，必须要尽可能的严格遵守规范。
或者说，使用已经经过了审核的，你也信任的polyfill，比如由[ES5-Shim](https://github.com/es-shims/es5-shim)或者[ES6-Shim](https://github.com/es-shims/es6-shim)提供的这些。

### Transpiling

在语法层面是没有任何办法去polyfill的，新的语法在旧的JS引擎中会直接抛出错误`unrecognized/invalid`。
所以，更好的选择是运用工具，把你的新代码转换为等价的旧代码。这个过程通常被称作"transpiling"，这个单词是由"transforming" + "compiling"合成的。
本质上来说，你的源代码是使用新的语法形式写的，但是你部署到浏览器的代码却是经过转换之后在旧的语法形式下的代码。通常，你需要将转换编译器插入到你构建项目的过程中，类似于你的代码风格检查器或者代码最小化工具。
可能你会很疑惑，为什么要这么麻烦的去使用新特性写代码然后转换到旧的——为什么不直接使用旧的语法来书写？

这里有几个比较重要的原因需要你注意：

* 添加到语言的新特性新语法的目的是为了提高你代码的可读性和可维护性。等价的旧代码往往是非常令人费解的，你应该更喜欢使用更新的代码更加清晰的语法，不仅为自己，也为自己团队中的其他成员。
* 如果你针对旧浏览器转换编译源代码，而针对新浏览器则使用新语法，你就能充分利用浏览器对于新语法的性能优化。这也让浏览器厂商能有更多的真实代码来测试自己的实现和优化。
* 在真实世界中更早的使用新的语法，将会提供给JavaScript委员会（T39），以供它们进行鲁棒性测试。如果更早的充分发现这些问题，他们就能在这些错误成为永久性错误之前将它修复。


这里有个转换编译的例子，ES6新增了“参数默认值”的特性，像这样：

```javascript
function foo(a = 2) {
    console.log( a );
}

foo();      // 2
foo( 42 );  // 42
```

很简单对吧，也很有用。但是这个语法在ES6之前的引擎中是无效的，那么转换编译器将代码转换成了什么，让它能够在旧环境中运行的呢？

```javascript
function foo() {
    var a = arguments[0] !== (void 0) ? arguments[0] : 2;
    console.log( a );
}
```

正如你所看到的，它将会检查`arguments[0]`的值，如果它等于`void 0`（等同于`undefined`），那么将它赋值为默认值`2`；否则等于传输进来的那个值。
现在，这个新的特性也能在旧的浏览器中使用了，看转换编译之后的代码是为了能更清楚的解释预处理的行为。
如果你仅仅是关注ES6版本的代码，可能你都还没有意识到，当外部没有值传入，从而将形参定义为默认值的时候，实际上外部传入的是`undefined`值。我们看了经过转换编译的代码后，能清楚的看到这一点。
关于转换编译我想最后强调一个重要的细节，它们现在被认为是JS发展生态系统和过程标准的一个重要部分。JS将会继续进化，更快速的进化，不过仅仅数月事件，就已经添加了非常多的新语法新特性。
在你使用转换编译器的时候，默认情况下，你应该总是选择最新的语法，无论它们是否有用。而不是等待多年逐步让今天的浏览器淘汰。

这里有几个强大的转换编译器供你选择：

* [Babel](https://babeljs.io)（以前的名字是"6to5"）：编译ES6+到ES5
* [Traceur](https://github.com/google/traceur-compiler)：编译ES6，ES7以及其他到ES5


## JavaScript之外

到目前为止，我们已经涵盖了JS语言本身的绝大部分内容，然而现实却是，JS代码写出来之后，将会运行在各种环境（比如浏览器）中，代码需要和它们进行各种交互。严格的来说，在你写好的大部分代码中，其实并不是直接由JavaScript来控制的。这听起来似乎有点奇怪？
比如你会碰到的DOM API，这是最为常见的非JavaScript的JavaScript代码：

```javascript
var el = document.getElementById( "foo" );
```

当你的代码运行在浏览器中时，将会存在一个全局变量`document`。它并不是JS引擎提供的，也并没有受到JavaScript规范的控制，它看起来很像是一个正常的JS对象，但也并不完全是。它是个很特殊的对象，通常我们称它为“宿主对象”。
另外，在`document`中的`getElementById(..)`方法看起来像是个普通的JS函数，但是它只是浏览器DOM对外暴露的接口，在某些（新一代）浏览器中，这一层可能还是JS，但是一般而言它的内部是由C/C++来实现的。
另外一个例子就是输入/输出(I/O)。
大家都最喜欢的`alert(..)`函数，它会在用户的浏览器窗口中弹出一个消息框。`alert(..)`也是由浏览器提供的，而不是JS引擎。您将信息发送至浏览器内部，然后由浏览器来绘制并显示消息框。
同样的还有`console.log(..)`，你的浏览器在开发者工具中提供了很多这样的工具。
这本书和整个系列都将会侧重于JavaScript语言本身，这也就是为什么你看不到这些大量的非JavaScript的内容的原因。但是，你在写你的JavaScript代码的时候，也必须小心它们！

## 综述

学习JavaScript的第一步，就是要对它的类型、值、函数、闭包、this以及原型等等这些核心机制有一个基本的了解。
当然，这里的每个主题的细节远比你在这本书中看到的要多得多，这也是为什么我们接下来的书籍会直接以它们命名。当你觉得本章中的概念和代码示例已经了若指掌，那么你可以开始学习本系列其余部分的书籍了。
本书最后一个章节将会简明扼要的总结本系列其他书籍的基本信息，当然，会排除我们已经介绍过的部分。

# 第三章：Into YDKJS

这个系列的主要内容是什么？简单的来说，它的任务是为了能认真学习JavaScript的全部，而不仅仅限于学习人们称之为“好的部分”的内容，而且也不会仅限于你能完成工作所需要的最小部分。
其他语言的开发者们总是期望能掌握这门语言的绝大部分内容，但是JS的开发者似乎和这群人有些不同，它们似乎并没有深入学习这门语言的欲望，我觉得这并不是一件好事，而且这种态度也不应该继续下去，以至于最后成为常态。
《你不懂JS》系列将会站在完全不同的角度来学习JS，它将和市面上其他学习JS的大部分书籍完全不同。它将会挑战你的舒适区，你遇到的每一个行为，它都会更深入的问你“为什么”。你准备好接受这样的挑战了吗？
我将会利用这最后一章简要的总结一下本系列的其它部分，以及如何最有效率的通过这个系列来建立JS的基础。

## 作用域和闭包

变量作用域是如何在JavaScript中工作的，这是你需要快速学习的基础概念。当然，这还不足以让你对作用域建立起一个模糊的认识。
《作用域和闭包》一书将会从揭穿“JS是个解释型语言”这样一个广泛的误解开始，当然，JS也并不是编译型的，绝不是的。
JS引擎将会在你运行代码之前编译代码（有些引擎会在执行的时候编译），为了能深入理解这一点，我们必须对编译器的编译方法有所了解，然后我们才能明白JavaScript到底是如何发现和处理变量和函数声明的。在上面的介绍中，我们也看到了JS变量作用域的一个典型副作用，“声明提升”。
对于词法作用域的深刻理解，将会是在最后一章中探索“闭包”的基础。闭包这个概念可能是JS的所有概念中最重要（没有之一）的。如果你没有能掌握作用域是如何工作的，闭包这个概念恐怕仍然有可能超出了你的理解范围。
闭包最重要的应用就是模块模式，我们在第二章已经对它进行了简单的介绍，模块化可能是现在在JavaScript中最为流行的代码组织方式了，深入理解它应该是你的首要任务。

## this和对象原型

在JavaScript中有一个最为广泛和持久的错误事实，那就是`this`关键字引用的是函数自身，真是糟糕的错误。
`this`关键字是根据函数如何运行从而动态绑定的。它有四个简单的规则，了解了这几个规则就能明白它是如何绑定的。
和`this`关键字关系最深的就是对象原型机制，即对象的属性查找链，它和在词法作用域中寻找变量有些相似。但是将原型封装起来却是另一种巨大的错误用法：模仿类和继承的设计模式。
不幸的是，想要把类和继承的设计模式带到JavaScript，这是你能尝试的最糟糕的事情了，虽然现在像是`class`这样的语法可能诱骗你去进行这样的尝试，但是原型链的机制从本质上来说和类继承的行为是完全相对的。
你是打算忽略那些不匹配的行为，然后假装实现了“继承”；还是说认真学习接受一种更契合对象原型系统的工作方式？后者有一个更合适的名字——“行为委托”。
这不仅仅是句法上偏好，“委托”是一种完全不同的，更为强大的设计模式，它完全可以用来代替类和继承。但是我的这些断言肯定会打那些在JavaScript整个生命周期中讨论这个主题的几乎所有的博客、书籍和会议的的脸。
我做出关于代理与继承的宣言，并非来自对语言和语法的反感，而是希望大家看到JS语言真正的能力并发挥它真正的价值，并且扫除那无尽的迷惑和无奈。
我提出的关于有关原型和委托的设计模式要更贴近于JavaScript的特性，对于你已经掌握的有关JavaScript类与继承的知识，如果你准备重新思考关于它们的一切，我为你提供了“选择红色药丸”的机会（黑客帝国：矩阵，1999），请查阅本系列标题为《this和对象原型》的第四到六章。

## 类型和语法

本系列的第三个主题主要集中在解决另一个极具争议的话题：强制类型转换。对于JS开发者而言，没有什么能比这个话题带来的更多的混乱和挫折感了。
到目前为止，传统的看法是隐式类型转换是JS语言的糟粕，应该不惜一切代价地避免它。事实上，有人竟然已经认为它是语言设计上的缺陷。而且，现在甚至有些工具专门扫描你的代码，一旦发现了类似强制类型转换的行为就会给你报错。
但是强制类型转换真的如此混乱、如此糟糕、如此狡诈吗？一旦你在代码中使用了它，就注定如此了吗？
要我说，绝不是的！在阅读完第1-3章，你会深入理解类型和值到底是怎么工作的，在第四章我将会展开这个讨论，我将会充分说明强制类型转换在所有情况下是如何工作的，如果你肯花时间学习，你将会看到强制类型转换那些令人惊讶的部分，那些确实有意义的部分。
但是，我并不是说强制类型转换是合理且容易学习的，我认为强制类型转换是个非常有用的且完全被低估的工具，你应该在代码中使用它。对于强制类型转换，如果使用得当，不仅有效而且它将极大的改善你的代码，所有的反对者和怀疑者肯定会嘲笑这样的观点，但是我坚信它是你升级你JS技能的主要钥匙之一。
你想继续保持那些“大多数”的观点，还是说你愿意抛开所有的臆测，用一个全新的视角去审视“强制转换”？《类型和语法》将会强制转换你的思维。

## 异步和性能

前三本书主要集中在语言的核心机制上，但是在第四本书，我们将会讲解语言的顶层模式：管理异步编程。异步不仅是程序性能的关键，也日益成为了可写性和可维护性的关键因素。
书中首先理清了很多容易混淆的概念，比如`异步`、`并行`以及`并发`等等。然后深入讲解了这些东西哪些适合JS，哪些不适合。
然后我们将会讲解让异步成为可能的重要技术：回调。但是，我们很快就能发现仅仅只有回调是完全不够的，它不能满足现代异步编程的需求。我们确定了回调的两个严重缺陷：控制反转（IoC）不可靠以及缺乏线性编程的能力。
为了解决这两个重大的缺陷，ES6引入了两个新的机制（事实上是模式）：`promises`和`generators`。
Promises是和时间无关的围绕着“未来值”的封装，无论值是否准备就绪，你都能直接使用和组合它们。此外，它们将路由回调通过一个可信和可组合的promise（承诺）机制，高效地解决了IoC信任问题。
Generators是JS函数引入一种新的执行模式，它在`yield`点可以被暂停，然后异步的恢复状态。Generator这种`暂停-恢复`的能力使得代码看起来是同步顺序的，但却可以用异步的方式进行处理。通过这样做，我们解决了回调带来的非线性和跳跃式的混乱，从而使我们的异步代码看起来像同步调用，看起来要更加合理，更加容易理解。
但是，将promises和generators的组合起来成为`"yields"`，这才是迄今为止在JavaScript中最有效的异步编程模式。事实上，在将要到来的ES7中，大部分关于未来异步的成熟机制，肯定都是建立在这个基础上的。如果你想要在异步的世界中更有效的编程，你必须要十分熟悉的结合promises和generators。
如果promises和generators是关于如何提高程序的并发性，从而在短时间内处理更多的任务的模式，那JS在关于性能优化的方面有许多值得探索的地方。
第五章深入研究了使用Web Workers来提高程序并行能力，如何使用SIMD提高数据并行，以及一些低级别的优化技术，如ASM.js。第六章讲解了通过合适的基准测试技术（包括担心什么样的性能问题以及忽略什么问题）的视角来看待性能优化。
编写高效的JavaScript代码，这意味着编写出来的代码可以打破在广泛的浏览器和其他环境中动态运行的限制。这需要大量复杂和详细的计划，以及我们自身的努力，将程序从“它能运行”进阶成“它能很好的运行”。
《异步和性能》提供了所有的工具和技能让你编写合理的、高性能的JavaScript代码。

## 超越ES6

目前为止，不管你觉得自己已经掌握了JavaScript，事实是JavaScript是永远不会停止进化的，而且，进化的速度变得更快了。这一事实也是这个系列的精神隐喻，拥抱我们永远不会完全知道JS的每一个部分这个事实，因为当你掌握了一切的时候，马上就会有新的东西出现，你又需要继续学习。
这个标题暗指这门语言短期和中期的发展远景，不仅仅是ES6中我们所知道的，也有超越了当前可能的东西。
这一系列的书籍都是在书写本书的时候JavaScript当前的状态，而ES6是中途加进来的，所以你会发现本系列的书主要还是集中在ES5上。现在，我希望把我们的注意力集中在ES6，ES7.....
在写这篇文章的时候，ES6基本快完成了，超越ES6一书从ES6的视角将具体的东西分成几个主要的类别，其中包括新的语法，新的数据结构，和新的处理功能和API。我们会在不同级别的细节上覆盖这些ES6新特性，包括重新复习我们已经在本系列其他书中提到的细节。
以下是一些ES6值得让我们兴奋的东西：destructuring, default parameter values, symbols, concise methods, computed properties, arrow functions, block scoping, promises, generators, iterators, modules, proxies, weakmaps以及很多很多其他特性！艹！ES6简直快把我砸晕了！
本书的第一部分是你需要学习的所有东西的路线图，这些都是有关新的和改进的JavaScript特性。
本书后半部分将注意力放在我们希望在不久的将来能在JavaScript中看到的东西。这里最重要的认识是，后ES6时代，JS更可能是根据功能来更新，而不是单纯根据版本来更新，这意味着我们期望在不久的未来可以看到的东西可能比你想象的来得更快。
JavaScript的未来是光明的，是时候开始学习它了！

## 综述

**YDKJS**系列认为所有的JS开发者可以并且应该学习这门伟大语言的所有部分。不用管别人的意见，不用管框架的假设，不用管项目的最后期限，这些都不应该成为你从来不学习和深入理解JavaScript的借口。
我们在语言的各重要领域贡献一本短小精悍的书，充分发掘你认为你已经知道的，但可能没有充分理解的所有部分。
“**You Don't Know JS**”并不是批评或侮辱（在座的各位）。这是我们所有人，包括我自己，一定要意识到的东西。学习JavaScript并不是最终目标，而是一个过程。我们现在不知道的JavaScript，在不远的未来我们肯定会知道！



# 附录：鸣谢

对于这本书以及这个系列来说，我有很多想要感谢的人。
首先，我想要感谢我的妻子Christen Simpson和我的两个孩子Ethan和Emily，感谢他们能忍受我总是杵在电脑前。即使是不写书，我对于JavaScript的痴迷仍然让我的眼睛盯着电脑的时间远超其他时间。我抽出了本应该陪伴家人的时间来写成了这本书，我亏欠家人实在是太多了。
我还要感谢我在O'Reilly的编辑Simon St.Laurent和Brian MacDonald，以及全体编辑和营销人员。与他们共事真的是非常棒，在这次“开源”图书写作、编辑和出版过程中，他们对我太迁就了。
感谢在该系列书编写过程提出修改建议和帮忙纠错的朋友，他们的贡献令本书增色不少，这些人包括但不限于Shelley Powers, Tim Ferro, Evan Borden, Forrest L. Norvell, Jennifer Davis, Jesse Harlin, Kris Kowal, Rick Waldron, Jordan Harband, Benjamin Gruenbaum, Vyacheslav Egorov, David Nolen。以及大大的感谢Jenn Lukas为本书“up & going”作序。
感谢社区中的所有人，包括TC39委员会的成员，他们分享了许多知识并且一直耐心而且细致地回答我接连不断的问题。这些人包括但不限于John-David Dalton, Juriy "kangax" Zaytsev, Mathias Bynens, Axel Rauschmayer, Nicholas Zakas, Angus Croll, Reginald Braithwaite, Dave Herman, Brendan Eich, Allen Wirfs-Brock, Bradley Meck, Domenic Denicola, David Walsh, Tim Disney, Peter van der Zee, Andrea Giammarchi, Kit Cambridge, Eric Elliott以及其他人，原谅我无法在这里一一列出。
由于本系列诞生于Kickstarter，我同样想感谢所有（接近）500个支持者，没有他们就没有这个系列：

> Jan Szpila, nokiko, Murali Krishnamoorthy, Ryan Joy, Craig Patchett, pdqtrader, Dale Fukami, ray hatfield, R0drigo Perez [Mx], Dan Petitt, Jack Franklin, Andrew Berry, Brian Grinstead, Rob Sutherland, Sergi Meseguer, Phillip Gourley, Mark Watson, Jeff Carouth, Alfredo Sumaran, Martin Sachse, Marcio Barrios, Dan, AimelyneM, Matt Sullivan, Delnatte Pierre-Antoine, Jake Smith, Eugen Tudorancea, Iris, David Trinh, simonstl, Ray Daly, Uros Gruber, Justin Myers, Shai Zonis, Mom & Dad, Devin Clark, Dennis Palmer, Brian Panahi Johnson, Josh Marshall, Marshall, Dennis Kerr, Matt Steele, Erik Slagter, Sacah, Justin Rainbow, Christian Nilsson, Delapouite, D.Pereira, Nicolas Hoizey, George V. Reilly, Dan Reeves, Bruno Laturner, Chad Jennings, Shane King, Jeremiah Lee Cohick, od3n, Stan Yamane, Marko Vucinic, Jim B, Stephen Collins, Ægir Þorsteinsson, Eric Pederson, Owain, Nathan Smith, Jeanetteurphy, Alexandre ELISÉ, Chris Peterson, Rik Watson, Luke Matthews, Justin Lowery, Morten Nielsen, Vernon Kesner, Chetan Shenoy, Paul Tregoing, Marc Grabanski, Dion Almaer, Andrew Sullivan, Keith Elsass, Tom Burke, Brian Ashenfelter, David Stuart, Karl Swedberg, Graeme, Brandon Hays, John Christopher, Gior, manoj reddy, Chad Smith, Jared Harbour, Minoru TODA, Chris Wigley, Daniel Mee, Mike, Handyface, Alex Jahraus, Carl Furrow, Rob Foulkrod, Max Shishkin, Leigh Penny Jr., Robert Ferguson, Mike van Hoenselaar, Hasse Schougaard, rajan venkataguru, Jeff Adams, Trae Robbins, Rolf Langenhuijzen, Jorge Antunes, Alex Koloskov, Hugh Greenish, Tim Jones, Jose Ochoa, Michael Brennan-White, Naga Harish Muvva, Barkóczi Dávid, Kitt Hodsden, Paul McGraw, Sascha Goldhofer, Andrew Metcalf, Markus Krogh, Michael Mathews, Matt Jared, Juanfran, Georgie Kirschner, Kenny Lee, Ted Zhang, Amit Pahwa, Inbal Sinai, Dan Raine, Schabse Laks, Michael Tervoort, Alexandre Abreu, Alan Joseph Williams, NicolasD, Cindy Wong, Reg Braithwaite, LocalPCGuy, Jon Friskics, Chris Merriman, John Pena, Jacob Katz, Sue Lockwood, Magnus Johansson, Jeremy Crapsey, Grzegorz Pawłowski, nico nuzzaci, Christine Wilks, Hans Bergren, charles montgomery, Ariel בר-לבב Fogel, Ivan Kolev, Daniel Campos, Hugh Wood, Christian Bradford, Frédéric Harper, Ionuţ Dan Popa, Jeff Trimble, Rupert Wood, Trey Carrico, Pancho Lopez, Joël kuijten, Tom A Marra, Jeff Jewiss, Jacob Rios, Paolo Di Stefano, Soledad Penades, Chris Gerber, Andrey Dolganov, Wil Moore III, Thomas Martineau, Kareem, Ben Thouret, Udi Nir, Morgan Laupies, jory carson-burson, Nathan L Smith, Eric Damon Walters, Derry Lozano-Hoyland, Geoffrey Wiseman, mkeehner, KatieK, Scott MacFarlane, Brian LaShomb, Adrien Mas, christopher ross, Ian Littman, Dan Atkinson, Elliot Jobe, Nick Dozier, Peter Wooley, John Hoover, dan, Martin A. Jackson, Héctor Fernando Hurtado, andy ennamorato, Paul Seltmann, Melissa Gore, Dave Pollard, Jack Smith, Philip Da Silva, Guy Israeli, @megalithic, Damian Crawford, Felix Gliesche, April Carter Grant, Heidi, jim tierney, Andrea Giammarchi, Nico Vignola, Don Jones, Chris Hartjes, Alex Howes, john gibbon, David J. Groom, BBox, Yu 'Dilys' Sun, Nate Steiner, Brandon Satrom, Brian Wyant, Wesley Hales, Ian Pouncey, Timothy Kevin Oxley, George Terezakis, sanjay raj, Jordan Harband, Marko McLion, Wolfgang Kaufmann, Pascal Peuckert, Dave Nugent, Markus Liebelt, Welling Guzman, Nick Cooley, Daniel Mesquita, Robert Syvarth, Chris Coyier, Rémy Bach, Adam Dougal, Alistair Duggin, David Loidolt, Ed Richer, Brian Chenault, GoldFire Studios, Carles Andrés, Carlos Cabo, Yuya Saito, roberto ricardo, Barnett Klane, Mike Moore, Kevin Marx, Justin Love, Joe Taylor, Paul Dijou, Michael Kohler, Rob Cassie, Mike Tierney, Cody Leroy Lindley, tofuji, Shimon Schwartz, Raymond, Luc De Brouwer, David Hayes, Rhys Brett-Bowen, Dmitry, Aziz Khoury, Dean, Scott Tolinski - Level Up, Clement Boirie, Djordje Lukic, Anton Kotenko, Rafael Corral, Philip Hurwitz, Jonathan Pidgeon, Jason Campbell, Joseph C., SwiftOne, Jan Hohner, Derick Bailey, getify, Daniel Cousineau, Chris Charlton, Eric Turner, David Turner, Joël Galeran, Dharma Vagabond, adam, Dirk van Bergen, dave ♥♫★ furf, Vedran Zakanj, Ryan McAllen, Natalie Patrice Tucker, Eric J. Bivona, Adam Spooner, Aaron Cavano, Kelly Packer, Eric J, Martin Drenovac, Emilis, Michael Pelikan, Scott F. Walter, Josh Freeman, Brandon Hudgeons, vijay chennupati, Bill Glennon, Robin R., Troy Forster, otaku_coder, Brad, Scott, Frederick Ostrander, Adam Brill, Seb Flippence, Michael Anderson, Jacob, Adam Randlett, Standard, Joshua Clanton, Sebastian Kouba, Chris Deck, SwordFire, Hannes Papenberg, Richard Woeber, hnzz, Rob Crowther, Jedidiah Broadbent, Sergey Chernyshev, Jay-Ar Jamon, Ben Combee, luciano bonachela, Mark Tomlinson, Kit Cambridge, Michael Melgares, Jacob Adams, Adrian Bruinhout, Bev Wieber, Scott Puleo, Thomas Herzog, April Leone, Daniel Mizieliński, Kees van Ginkel, Jon Abrams, Erwin Heiser, Avi Laviad, David newell, Jean-Francois Turcot, Niko Roberts, Erik Dana, Charles Neill, Aaron Holmes, Grzegorz Ziółkowski, Nathan Youngman, Timothy, Jacob Mather, Michael Allan, Mohit Seth, Ryan Ewing, Benjamin Van Treese, Marcelo Santos, Denis Wolf, Phil Keys, Chris Yung, Timo Tijhof, Martin Lekvall, Agendine, Greg Whitworth, Helen Humphrey, Dougal Campbell, Johannes Harth, Bruno Girin, Brian Hough, Darren Newton, Craig McPheat, Olivier Tille, Dennis Roethig, Mathias Bynens, Brendan Stromberger, sundeep, John Meyer, Ron Male, John F Croston III, gigante, Carl Bergenhem, B.J. May, Rebekah Tyler, Ted Foxberry, Jordan Reese, Terry Suitor, afeliz, Tom Kiefer, Darragh Duffy, Kevin Vanderbeken, Andy Pearson, Simon Mac Donald, Abid Din, Chris Joel, Tomas Theunissen, David Dick, Paul Grock, Brandon Wood, John Weis, dgrebb, Nick Jenkins, Chuck Lane, Johnny Megahan, marzsman, Tatu Tamminen, Geoffrey Knauth, Alexander Tarmolov, Jeremy Tymes, Chad Auld, Sean Parmelee, Rob Staenke, Dan Bender, Yannick derwa, Joshua Jones, Geert Plaisier, Tom LeZotte, Christen Simpson, Stefan Bruvik, Justin Falcone, Carlos Santana, Michael Weiss, Pablo Villoslada, Peter deHaan, Dimitris Iliopoulos, seyDoggy, Adam Jordens, Noah Kantrowitz, Amol M, Matthew Winnard, Dirk Ginader, Phinam Bui, David Rapson, Andrew Baxter, Florian Bougel, Michael George, Alban Escalier, Daniel Sellers, Sasha Rudan, John Green, Robert Kowalski, David I. Teixeira (@ditma, Charles Carpenter, Justin Yost, Sam S, Denis Ciccale, Kevin Sheurs, Yannick Croissant, Pau Fracés, Stephen McGowan, Shawn Searcy, Chris Ruppel, Kevin Lamping, Jessica Campbell, Christopher Schmitt, Sablons, Jonathan Reisdorf, Bunni Gek, Teddy Huff, Michael Mullany, Michael Fürstenberg, Carl Henderson, Rick Yoesting, Scott Nichols, Hernán Ciudad, Andrew Maier, Mike Stapp, Jesse Shawl, Sérgio Lopes, jsulak, Shawn Price, Joel Clermont, Chris Ridmann, Sean Timm, Jason Finch, Aiden Montgomery, Elijah Manor, Derek Gathright, Jesse Harlin, Dillon Curry, Courtney Myers, Diego Cadenas, Arne de Bree, João Paulo Dubas, James Taylor, Philipp Kraeutli, Mihai Păun, Sam Gharegozlou, joshjs, Matt Murchison, Eric Windham, Timo Behrmann, Andrew Hall, joshua price, Théophile Villard

本系列书的写作是开源的，包括编辑和出版。我们要感谢GitHub提供的社区协作功能！
再次感谢，我无法列出所有人的名字，但是非常感谢你们。希望本书可以被所有人“拥有”，能促进大家对于JavaScript语言的理解，能帮助现在和未来的社区贡献者们。

